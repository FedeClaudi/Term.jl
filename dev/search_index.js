var documenterSearchIndex = {"docs":
[{"location":"api_term/","page":"Term","title":"Term","text":"CurrentModule = Term","category":"page"},{"location":"api_term/","page":"Term","title":"Term","text":"Modules = [Term]","category":"page"},{"location":"api_term/#Term.ANSICode-Tuple{Any}","page":"Term","title":"Term.ANSICode","text":"ANSICode(color; bg::Bool=false)\n\nCreate ANSI tags for colors.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.CodeTheme","page":"Term","title":"Term.CodeTheme","text":"Custom hilighting theme for Highlighters.jl https://juliadocs.github.io/Highlights.jl/stable/man/theme/\n\n\n\n\n\n","category":"type"},{"location":"api_term/#Term.Theme","page":"Term","title":"Term.Theme","text":"Theme\n\nStores colors for different semantically relevant items, used to  style outputs to terminal.\n\n\n\n\n\n","category":"type"},{"location":"api_term/#Term.measure.Measure-Tuple{Term.segment.Segment}","page":"Term","title":"Term.measure.Measure","text":"Measure(seg::Segment)\n\ngives the measure of a segment\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.measure.Measure-Tuple{Vector{Term.segment.Segment}}","page":"Term","title":"Term.measure.Measure","text":"Measure(segments::Vector{Segment})\n\ngives the measure of a vector of segments\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Highlights.Format.render-Tuple{IO, MIME{Symbol(\"text/ansi\")}, Highlights.Format.TokenIterator}","page":"Term","title":"Highlights.Format.render","text":"Format.render(io::IO, ::MIME\"text/ansi\", tokens::Format.TokenIterator)\n\ncustom ANSI lexer for Highlighters.jl\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.chars-Tuple{AbstractString}","page":"Term","title":"Term.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.cleantext-Tuple{AbstractString}","page":"Term","title":"Term.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.do_by_line-Tuple{Function, AbstractString}","page":"Term","title":"Term.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.escape_brackets-Tuple{AbstractString}","page":"Term","title":"Term.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Term","title":"Term.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Term","title":"Term.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Term","title":"Term.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.highlight-Tuple{AbstractString, Term.Theme, Symbol}","page":"Term","title":"Term.highlight","text":"highlight(text::AbstractString, theme::Theme, like::Symbol)\n\nHilights an entire text as if it was a type of semantically relevant text of type :like.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.highlight-Tuple{AbstractString, Term.Theme}","page":"Term","title":"Term.highlight","text":"highlight(text::AbstractString, theme::Theme)\n\nHighlighs a text introducing markup to style semantically relevant segments, colors specified by a theme object\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.highlight_syntax-Tuple{AbstractString}","page":"Term","title":"Term.highlight_syntax","text":"highlight_syntax(code::AbstractString; style::Bool=true)\n\nHighlight Julia code syntax in a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.join_lines-Tuple{Any}","page":"Term","title":"Term.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.load_code_and_highlight-Tuple{AbstractString, Int64}","page":"Term","title":"Term.load_code_and_highlight","text":"load_code_and_highlight(path::AbstractString, lineno::Int; δ::Int=3, width::INt=120)\n\nLoad a file, get the code and format it. Return styled text\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.nospaces-Tuple{AbstractString}","page":"Term","title":"Term.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Term","title":"Term.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.reinsert_double_brackets-Tuple{AbstractString}","page":"Term","title":"Term.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_ansi-Tuple{AbstractString}","page":"Term","title":"Term.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_brackets-Tuple{AbstractString}","page":"Term","title":"Term.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_markup-Tuple{AbstractString}","page":"Term","title":"Term.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_markup_open-Tuple{AbstractString}","page":"Term","title":"Term.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.replace_double_brackets-Tuple{AbstractString}","page":"Term","title":"Term.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.replace_text","page":"Term","title":"Term.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_term/#Term.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Term","title":"Term.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.reshape_text-Tuple{AbstractString, Int64}","page":"Term","title":"Term.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.split_lines-Tuple{AbstractString}","page":"Term","title":"Term.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.split_lines-Tuple{Any}","page":"Term","title":"Term.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.square_to_round_brackets-Tuple{AbstractString}","page":"Term","title":"Term.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.textlen-Tuple{AbstractString}","page":"Term","title":"Term.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.truncate-Tuple{AbstractString, Int64}","page":"Term","title":"Term.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.unescape_brackets-Tuple{AbstractString}","page":"Term","title":"Term.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.unspace_commas-Tuple{AbstractString}","page":"Term","title":"Term.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.@make_color_macro-Tuple{Any}","page":"Term","title":"Term.@make_color_macro","text":"Macro to create macros such as @green which colors text accordingly\n\n\n\n\n\n","category":"macro"},{"location":"api_term/#Term.@make_mode_macro-Tuple{Any}","page":"Term","title":"Term.@make_mode_macro","text":"Macro to create macros such as @underline which styles text accordingly.\n\n\n\n\n\n","category":"macro"},{"location":"api_term/#Term.@style-Tuple{Any, Vararg{Any, N} where N}","page":"Term","title":"Term.@style","text":"@style \"text\" style1 style2...\n\nApplies a sequence of styles to a piece of text, such that\n\nprintln(@style \"my text\" bold green underline)\n\nwill print my text as bold, green and underlined\n\n\n\n\n\n","category":"macro"},{"location":"api_markup/","page":"markup","title":"markup","text":"CurrentModule = Term.markup","category":"page"},{"location":"api_markup/","page":"markup","title":"markup","text":"Modules = [markup]","category":"page"},{"location":"api_markup/#Term.markup.MarkupTag","page":"markup","title":"Term.markup.MarkupTag","text":"MarkupTag\n\nRepresents a complete markup tag.\n\nIt stores two SingleTag, the text inbetween and any other MarkupTag that was detected in that text.\n\n\n\n\n\n","category":"type"},{"location":"api_markup/#Term.markup.SingleTag","page":"markup","title":"Term.markup.SingleTag","text":"SingleTag\n\nRepresents a single tag [style] or [/style]\n\n\n\n\n\n","category":"type"},{"location":"api_markup/#Term.markup.SingleTag-Tuple{RegexMatch}","page":"markup","title":"Term.markup.SingleTag","text":"SingleTag(match::RegexMatch)\n\nConstruct a SingleTag out of a RegexMatch\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.chars-Tuple{AbstractString}","page":"markup","title":"Term.markup.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.clean_nested_tags-Tuple{AbstractString}","page":"markup","title":"Term.markup.clean_nested_tags","text":"clean_nested_tags(text::AbstractString)::AbstractString\n\nGiven a text with nested string like: [red]aaaa [green]bbbb[/green] cccc [blue] ddddd [/blue]eeee[/red]\n\nit adds extra tags to ensure that text within inner tags is handled properly, giving: [red]aaaa [green]bbbb[/green][red] cccc [/red][blue] ddddd [/blue][red]eeee[/red]\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.clean_nested_tags-Tuple{Term.markup.MarkupTag, AbstractString}","page":"markup","title":"Term.markup.clean_nested_tags","text":"clean_nested_tags(tag, text::AbstractString)\n\nrecursively applies to inner tags\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.cleantext-Tuple{AbstractString}","page":"markup","title":"Term.markup.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.do_by_line-Tuple{Function, AbstractString}","page":"markup","title":"Term.markup.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.escape_brackets-Tuple{AbstractString}","page":"markup","title":"Term.markup.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.extract_markup-Tuple{AbstractString}","page":"markup","title":"Term.markup.extract_markup","text":"extract_markup(input_text::AbstractString; firstonly=false)\n\nExtracts MarkupTags from a piece of text.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"markup","title":"Term.markup.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"markup","title":"Term.markup.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"markup","title":"Term.markup.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.has_markup-Tuple{AbstractString}","page":"markup","title":"Term.markup.has_markup","text":"has_markup(text::AbstractString)\n\nReturns true if text includes a MarkupTag\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.join_lines-Tuple{Any}","page":"markup","title":"Term.markup.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.nospaces-Tuple{AbstractString}","page":"markup","title":"Term.markup.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.pairup_tags-Tuple{Vector{AbstractString}}","page":"markup","title":"Term.markup.pairup_tags","text":"pairup_tags(text::Vector{AbstractString})\n\nGiven a vector of string with markup tags not properly closed/opened across lines,  it fixes things up.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"markup","title":"Term.markup.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.reinsert_double_brackets-Tuple{AbstractString}","page":"markup","title":"Term.markup.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_ansi-Tuple{AbstractString}","page":"markup","title":"Term.markup.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_brackets-Tuple{AbstractString}","page":"markup","title":"Term.markup.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_markup-Tuple{AbstractString}","page":"markup","title":"Term.markup.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_markup_open-Tuple{AbstractString}","page":"markup","title":"Term.markup.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.replace_double_brackets-Tuple{AbstractString}","page":"markup","title":"Term.markup.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.replace_text","page":"markup","title":"Term.markup.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_markup/#Term.markup.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"markup","title":"Term.markup.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.reshape_text-Tuple{AbstractString, Int64}","page":"markup","title":"Term.markup.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.split_lines-Tuple{AbstractString}","page":"markup","title":"Term.markup.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.split_lines-Tuple{Any}","page":"markup","title":"Term.markup.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.square_to_round_brackets-Tuple{AbstractString}","page":"markup","title":"Term.markup.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.textlen-Tuple{AbstractString}","page":"markup","title":"Term.markup.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.truncate-Tuple{AbstractString, Int64}","page":"markup","title":"Term.markup.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.unescape_brackets-Tuple{AbstractString}","page":"markup","title":"Term.markup.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.unspace_commas-Tuple{AbstractString}","page":"markup","title":"Term.markup.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"styled_text/#Styled-text","page":"styled text","title":"Styled text","text":"","category":"section"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"The term styled text refers to text printed out to a terminal (or other ::IO) with either color or other style (e.g., bold, italic) information. This is done by adding ANSI escape sequences in a string being printed to the terminal. These escape sequences are not rendered as caracters but add the style information.","category":"page"},{"location":"styled_text/#Style-macros","page":"styled text","title":"Style macros","text":"","category":"section"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"The easiest way to add style information to a String in Term is using the dedicated macros:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"using Term\nprintln(@green \"this is green\")\nprintln(@blue \"and this is blue\")\nprint(\"\\n\")\nprintln(@bold \"this is bold\")\nprintln(@underline \"and this is underlined\")","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"For color you can use these macros: @black, @red, @green, @yellow, @blue, @magenta, @cyan, @white, @default. While for styling you have: @bold @dim @italic @underline.","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Note that the styling macros return a string, so you can combine the resulting strings as you would normally:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"using Term # hidden\nprintln(\n    @green(\"This is green\") * \" and \" * @red(\"this is red\")\n)\nprintln(\n    \"Make your text $(@underline(\"stand out\"))!\"\n)","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"With these style macros you can do some simply styling, but it gets clunky when you want to go beyond adding some color. Let's say you want you text to be blue, bold and underlined; do you really need to use three macros?","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Of course not, you can use the @style macro!","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"using Term # hidden\nmytext = @style \"this is my text\" blue bold underline\nprintln(mytext)","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Like the macros you already know, @style returns a string with the desired style, except that now you can specify multiple styles at once! ","category":"page"},{"location":"styled_text/#Markup-text","page":"styled text","title":"Markup text","text":"","category":"section"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"The basic styling macros are great for handling simple cases where you just want to add a bit of style to a piece of text. More realistically, you might want more control about exactly which parts of your text have what style. ","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"As a way of example, let's say you want every other word of yours string:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"str=\"Every other word has colors!\"","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"to have a color. You could do it with macros:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"using Term # hidden\ne = @red \"Every\"\no = \"other\"\nw = @green \"word\"\nh = \"has\"\nc = @blue \"colors!\"\n\nprint(join((e, o, w, h, c), \" \"))","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"but that's awful. String interpolation would also not be of much help here. Instead, it would be great if we could specify styles directly inside a normal string and let Term figure it out.","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Well, that's exactly what we're going to do:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"import Term: tprint\ntprint(\n    \"[red]Every[/red] other [green]word[/green] has [blue]colors![/blue]\"\n)","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Woah! What just happened!! Two things happened: 1) Term styling machinery detects strings segments like \"[red]Every[/red]\" as meaning that the text between \"[...]\" and \"[/...]\" should be colored red and 2) tprint (short for term print) detects this style information and applies it to your text before printing. ","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Not bad huh? Even better, the style information inside a parentheses can be more than just color:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"using Term # hidden\ntprint(\n    \"[bold black underline on_red]So much [gold3 bold]STYLE[/gold3 bold] in this text[/bold black underline on_red]\"\n)","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"that's right, Term.jl can also color the background of your text (by adding on_C to your color C you set it as the background, see !!!! COLORS !!! page). Also, you might have noticed, Term can also handle nested style tags!","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"If you just want to use Term.jl's style functionality, just make sure to read the admonition below. If you're curious about what's happening under the hood, read on below!","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"warning: A note on style tags\nThe style tags used by Term.jl have an opening \"[style]\" and closing \"[/style]\" syntax. The style is applied to everything inbetween. For \"[/style]\" to close \"[style]\" the text in the parentheses must match exactly (excuding /), up to the number and position of spaces and the words order. So:\"[red] wohoo [/red]\"  # works\n\"[red] wohoo [/red ]\" # doesn't\n\"[bold blue] wohoo [/bold blue]\" # works\n\"[bold blue] wohoo [/blue bold]\" # doesn't","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"tip: Tip\nOccasionally you can do without the closing tag:tprint(\"[red]text\")Term.jl will add the closing tag to the end of the string for you. Generally though, when multiple styles are  applied to the same string, it's better to be explicit in exactly where each style starts and ends.","category":"page"},{"location":"styled_text/#Under-the-hood.","page":"styled text","title":"Under the hood.","text":"","category":"section"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"If you're reading here you're curious about what exactly is happening under the hood. So let's get started. Term.jl, like rich in python, defines a simple markup language to specify the style of bits of strins. As we saw, the syntax is very simple with an opening and closing tag specifying the style and marking the start and end of the styled text. ","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"So the first thing that needs to happen is the detection of these markup tags. This is surprisingly hard because there's so many possible combinations. You can have markup tags whose style information varies considerably, you can have nested tags, you can have tags spread across lines and you can have nested tags spread across lines:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"using Term # hidden\ntprint(\n    \"\"\"\nAnd [blue] somehow\nit [bold red] all [/bold red]\nhas to [green underline] always\nwork [/green underline] correctly [/blue]\nsomehow.\n    \"\"\"\n)","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"CurrentModule = Term.markup","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"All of this is taken care of by extract_markup which returns a vector of MarkupTag objects. Each of these stores the opening and close tags (as SingleTag objects), the text inbetween them as well as a reference to all MarkupTags nested in it.","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"Normally, you should never use extract_markup directly. Instead you can let `apply_style handle it. When passed a String, apply_style will use extract_markup to extract style information before applying it to the string. This is done one MarkupTag at the time and recursively (i.e., dealing with nested tags before moving on to the next) until no markup information is found. ","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"After extracting style information, apply_style replaces the MarkupTag information with the appropriate ANSI escape codes. This is done by parsing the markup information (the text bewteen [...]) into a `MarkupStyle' object which stores the style information. Finally, get_style_codes get the ANSI codes corresponding to the required style.  So in summary:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"import Term.style: apply_style  # hidden\napply_style(\"[red]text[/red]\")","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"will return a string with style information","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"import Term.style: apply_style  # hidden\napply_style(\"[red]text[/red]\") # hidden","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"which printed to the console looks like:","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"import Term.style: apply_style  # hidden\nprint(apply_style(\"[red]text[/red]\"))","category":"page"},{"location":"styled_text/","page":"styled text","title":"styled text","text":"end","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Term","category":"page"},{"location":"","page":"Home","title":"Home","text":"Term.jl is a Julia library for producing, styled and beautiful terminal output, like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Term\nprint(Term.make_logo())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Term.jl uses a simple markup syntax to add style information to standard Julia strings. It also provides Renderable objects such as the Panels and TextBoxes that you can see in the example below. These too can be styled, and include styled text, but more importantly they can benested and stacked to produce structured visual displays in your terminal. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In a Julia script:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkd\n\nPkg.add(\"Term\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or in the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]  # enters the pkg interface\npkg> add Term","category":"page"},{"location":"","page":"Home","title":"Home","text":"done!","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rest of the documentation is dedicated to explaining the basic concepts behavind Term.jl and how to use Term to produce styled terminal text.  Head to the GitHub repository to find several detailed examples or jump in the Discussions to start chatting with us. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"!!! note \"A note on Rich     Term.jl is based on a pre-existing package called rich (see here) developed by Will McGugan.     While most of how Term.jl handles things under the hood is specific to Term, the basic concepts behind how to even begin creating fancy terminal     outputs like the ones that rich and Term can produce are entirely Will's work. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We're very thankful to Will for making `rich`'s code open soruce and for the help and encouragement during the development of `Term`.","category":"page"}]
}
