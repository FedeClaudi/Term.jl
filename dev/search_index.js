var documenterSearchIndex = {"docs":
[{"location":"api_layout/","page":"Layout","title":"Layout","text":"CurrentModule = Term.layout","category":"page"},{"location":"api_layout/","page":"Layout","title":"Layout","text":"Pages   = [\"api_layout.md\"]","category":"page"},{"location":"api_layout/","page":"Layout","title":"Layout","text":"Modules = [layout]","category":"page"},{"location":"api_layout/#Term.layout.Padding","page":"Layout","title":"Term.layout.Padding","text":"Padding\n\nStores empty string to pad a string to the desired with.\n\n\n\n\n\n","category":"type"},{"location":"api_layout/#Term.layout.Padding-Tuple{AbstractString, Int64, Symbol}","page":"Layout","title":"Term.layout.Padding","text":"Padding(text::AbstractString, target_width::Int, method::Symbol)::Padding\n\nCreate Padding for a string given a justification method ∈ (:left, :center, :right).\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.Spacer","page":"Layout","title":"Term.layout.Spacer","text":"    Spacer\n\nA box of empty text with given width and height.\n\n\n\n\n\n","category":"type"},{"location":"api_layout/#Term.layout.hLine","page":"Layout","title":"Term.layout.hLine","text":"hLine\n\nA 1-line renderable made of repeated character from a Box.\n\n\n\n\n\n","category":"type"},{"location":"api_layout/#Term.layout.hLine-Tuple{AbstractString}","page":"Layout","title":"Term.layout.hLine","text":"hLine(text::AbstractString; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nConstruct an hLine as wide as the stdout with centered text.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.hLine-Tuple{Number, String}","page":"Layout","title":"Term.layout.hLine","text":"hLine(width::Number, text::String; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nCreates an hLine object with texte centered horizontally.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.hLine-Tuple{Number}","page":"Layout","title":"Term.layout.hLine","text":"hLine(width::Number, style::Union{String, Nothing}; box::Symbol=:ROUNDED)\n\nCreate a styled hLine of given width.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.hLine-Tuple{}","page":"Layout","title":"Term.layout.hLine","text":"hLine(; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nConstruct an hLine as wide as the stdout\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.vLine","page":"Layout","title":"Term.layout.vLine","text":"vLine\n\nA multi-line renderable with each line made of a | to create a vertical line\n\n\n\n\n\n","category":"type"},{"location":"api_layout/#Term.layout.vLine-Tuple{Number}","page":"Layout","title":"Term.layout.vLine","text":"vLine(height::Number, style::Union{String, Nothing}; box::Symbol=:ROUNDED)\n\nCreate a vLine given a height and, optionally, style information.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.vLine-Tuple{}","page":"Layout","title":"Term.layout.vLine","text":"vLine(; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nCreate a vLine as tall as the stdout console\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.chars-Tuple{AbstractString}","page":"Layout","title":"Term.layout.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.cleantext-Tuple{AbstractString}","page":"Layout","title":"Term.layout.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.do_by_line-Tuple{Function, AbstractString}","page":"Layout","title":"Term.layout.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.escape_brackets-Tuple{AbstractString}","page":"Layout","title":"Term.layout.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Layout","title":"Term.layout.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Layout","title":"Term.layout.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Layout","title":"Term.layout.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.hstack-Tuple","page":"Layout","title":"Term.layout.hstack","text":"hstack(renderables...)\n\nHorizonatlly stack a variable number of renderables\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.hstack-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}, Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Layout","title":"Term.layout.hstack","text":"hstack(r1::RenderablesUnion, r2::RenderablesUnion)\n\nHorizontally stack two renderables to give a new renderable.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.join_lines-Tuple{Any}","page":"Layout","title":"Term.layout.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.nospaces-Tuple{AbstractString}","page":"Layout","title":"Term.layout.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Layout","title":"Term.layout.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.reinsert_double_brackets-Tuple{AbstractString}","page":"Layout","title":"Term.layout.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.remove_ansi-Tuple{AbstractString}","page":"Layout","title":"Term.layout.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.remove_brackets-Tuple{AbstractString}","page":"Layout","title":"Term.layout.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.remove_markup-Tuple{AbstractString}","page":"Layout","title":"Term.layout.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.remove_markup_open-Tuple{AbstractString}","page":"Layout","title":"Term.layout.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.replace_double_brackets-Tuple{AbstractString}","page":"Layout","title":"Term.layout.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.replace_text","page":"Layout","title":"Term.layout.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_layout/#Term.layout.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Layout","title":"Term.layout.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.reshape_text-Tuple{AbstractString, Int64}","page":"Layout","title":"Term.layout.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.split_lines-Tuple{AbstractString}","page":"Layout","title":"Term.layout.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.split_lines-Tuple{Any}","page":"Layout","title":"Term.layout.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.square_to_round_brackets-Tuple{AbstractString}","page":"Layout","title":"Term.layout.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.textlen-Tuple{AbstractString}","page":"Layout","title":"Term.layout.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.truncate-Tuple{AbstractString, Int64}","page":"Layout","title":"Term.layout.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.unescape_brackets-Tuple{AbstractString}","page":"Layout","title":"Term.layout.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.unspace_commas-Tuple{AbstractString}","page":"Layout","title":"Term.layout.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.vstack-Tuple","page":"Layout","title":"Term.layout.vstack","text":"vstack(renderables...)\n\nVertically stack a variable number of renderables\n\n\n\n\n\n","category":"method"},{"location":"api_layout/#Term.layout.vstack-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}, Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Layout","title":"Term.layout.vstack","text":"vstack(r1::RenderablesUnion, r2::RenderablesUnion)\n\nVertically stack two renderables to give a new renderable.\n\n\n\n\n\n","category":"method"},{"location":"renderables/#Renderables","page":"Renderables","title":"Renderables","text":"","category":"section"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"In the previous section we...","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"using Term  # hidden\ntprint(\"[green]...have seen how to add some [gold3 bold underline]style[/gold3 bold underline] to our text\")  # hidden","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"and that's great, but it's not enough. If you want to create really beutiful and structured terminal outputs, a bit of color and bold text is not enough. You want to be able to create panels to separate different pieces of content, lines to mark out different sections, you want to be able to control the aspect (e.g.,, line length) of the content you're printing and, most importantly, you want to do all this without too many headaches. Term.jl has got your back.","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"In this section we will look at Renderable objects (subtypes of AbstractRenderable) such as TextBox and Panel. In the next page we will focus on how to compose multiple renderables into a layout and we'll introduce renderables such as hLine and Spacer that are best introduced in that context.","category":"page"},{"location":"renderables/#AbsractRenderable","page":"Renderables","title":"AbsractRenderable","text":"","category":"section"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"This section focuses a bit on how renderables work under the hood. If you just want use Term and you don't care too much for how it works, skip ahead to the next section!","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"When you venture beyond styling simple strings, virtually every object you'll encounter will be a subtype of the AbstractRenderable. We will call these objects renderables. Renderable types vary, but they all must have two fields: :segments and :measure.","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"note: Segment & Measure\nA Segment is simply a line of text, kinda. The segment type:    struct Segment\n        text::AbstractString   # text with ANSI codes injected\n        plain::AbstractString  # plain text with no style\n        measure::Measure       # measure of plain text\n    endstores a bit of plain text (i.e. without any style information) but also the same text with style information (text). Text is created as described earlier, using apply_style. The other bit of information is the Measure object. Measure keeps track of the size of objects as they will be rendered in the terminal (i.e., wihtout style markup or ANSI codes). It sores a width (w) and height (h) attribute keeping track of text width and number of lines. The Measure of a segment is just that: the textwidth of Segment.plain and the number of lines in it. When creating a renderable. This will generally produce the content that will be ultimately be printed to te terminal by generating a list of Segments. When the renderable is printed out, its Segment.texts are printed to the console in sequence. The Measure of a renderable is a combination of the Measure of the individual segments. It provides information about the renderable's width and number of lines, crucial when creating layouts!","category":"page"},{"location":"renderables/#Renderable","page":"Renderables","title":"Renderable","text":"","category":"section"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"The most generic renderable type is the creatively named Renderable. You'll very rarely create an instance of a Renderable from scratch. More generally Term will create one while performing another operation. For example: in the next page we'll see how to stack multiple renderables to crate a complex layout. Each renderable can be any AbstractRenderable-like object (including string). So if you're stacking a Panel, a TextBox an a String, what type should the resulting renderable object be? Well the generic but useful Renderable of course. ","category":"page"},{"location":"renderables/#RenderableText","page":"Renderables","title":"RenderableText","text":"","category":"section"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Now we get to more interesting stuff: RenderableText. What is it? Exactly what the name says, a renderable that stores a bit of text:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"using Term # hide\nrend = RenderableText(\"\"\"\n    [bold red]Woah, my first [yellow italic]`Renderable`!\n\"\"\")\nprint(rend)","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Nothing special here. You'll notice that RenderableText automatically applies style information though. Also, when we were just styling strings before we had to use tprint instead of the normal print function to get our styled output. Well no more! Renderable objects work well with print so you can drop that t. ","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Now, do we really need a whole new type just to print a bit of text? Of course not, but RenderableText does more than that!","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"import Term: RenderableText\n\nrend = RenderableText(\".\"^100; width=25)\nprint(rend)","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"magic! When we pass a width argument RenderableText reshapes our input text to the desired width! As you can imagine, when you're creating a layout made up of multiple elements, you want to be able to control the width of each element, so here you go!","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Now, as a reward for getting this far into the docs, a little sneak preview at renderables stacking:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"import Term: RenderableText # hide\n\nlorem = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\" # hide\n\nt1 = RenderableText(lorem; width=25)\nt2 = RenderableText(lorem; width=42)\nrend = t1 / \"\\n [bold green]second paragraph[/bold green] \\n\" / t2  # stacking syntax!!! - the result is typeof `Renderable`\nprint(rend)","category":"page"},{"location":"renderables/#Panel","page":"Renderables","title":"Panel","text":"","category":"section"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Okay, time to move beyond simple text. It's time for:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"import Term: Panel # hide\n\nprint(\n    Panel(\n        \"[red]awesome[/red]\",\n        title=\"Term's\",\n        title_style=\"bold green\",\n        style=\"gold1 bold\",\n        subtitle=\"Panels\",\n        subtitle_style=\"bold blue\",\n        subtitle_justify=:right,\n        width=18,\n        justify=:center\n    )\n) # hide","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Simpli put, a Panel showing a piece of content (generally a styled string, but it can be any Renderable really) surrounded by a box. Simple but effective.","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Well not that simple actually because Panel is the first renderable that allows you lots of options to personalize its appearance. For instance the panel printed above is given by:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"    Panel(\n        \"[red]awesome[/red]\",\n        title=\"Term's\",\n        title_style=\"bold green\",\n        style=\"gold1 bold\",\n        subtitle=\"Panels\",\n        subtitle_style=\"bold blue\",\n        subtitle_justify=:right,\n        width=18,\n        justify=:center\n    )","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"The first argument is the content, the rest is styling options. As you can see you can specify the titles and subtitles (or leave them out if you prefer, do your thing!), their appearance (via markup style information) and their position (:left, :center or :right). The style argument sets the style of the box itself (and title/subtitle if they don't have dedicated style information).","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"The box is created using Term's own Box type! It's not worth going too much into exactly how it works, but it's worth pointing out that there's loads of types of boxes:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"ASCII,\nASCII2,\nASCII_DOUBLE_HEAD,\nSQUARE,\nSQUARE_DOUBLE_HEAD,\nMINIMAL,\nMINIMAL_HEAVY_HEAD\nMINIMAL_DOUBLE_HEAD,\nSIMPLE,\nSIMPLE_HEAD,\nSIMPLE_HEAVY,\nHORIZONTALS,\nROUNDED,\nHEAVY\nHEAVY_EDGE,\nHEAVY_HEAD,\nDOUBLE,\nDOUBLE_EDGE","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"And you can use any of these with your panels:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"\nimport Term: Panel # hide\n\nprint(\n    Panel(width=8, box=:DOUBLE, style=\"green\") *\n    Panel(width=8, box=:HEAVY, style=\"white\") *\n    Panel(width=8, box=:ROUNDED, style=\"red\"),\n)","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"By the way, Panels are not limited to having strings as content, they can have other renderables too (multiple ones in fact)!","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"\nimport Term: Panel # hide\n\nprint(\n    Panel(\n        Panel(width=18, style=\"green\"),\n        Panel(width=18, style=\"white\"),\n        Panel(width=18, style=\"red\"),\n        title=\"so many panels!\",\n        width=:fit,\n        title_justify=:left,\n        title_style=\"bold red\"\n    )\n)","category":"page"},{"location":"renderables/#TextBox","page":"Renderables","title":"TextBox","text":"","category":"section"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"TextBoxes are a very simple but very useful renderable. They bring together RenderableText with Panel. In fact they're just a panel with a RenderableText inside and with its box hidden.  Why do we need them, you say? Well because now you can have a piece of text, with a nice title and sub title.","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"import Term: TextBox\n\nprint(\n    TextBox(\n        \",\"^100 * \"\\n\",\n        title=\"title!\",\n        subtitle=\"sub title!\",\n        width=30,\n        title_style=\"bold red\",\n        subtitle_style=\"dim\",\n        title_justify=:center,\n    )\n)","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Okay, admittedly that's not huge. But it still nice to have. It also helps with keeping layout consistent when mixing panels and text, have a look:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"import Term: RenderableText, Panel\n\nt = \",\"^100\n\ntext = RenderableText(t; width=22)\npanel = Panel(t, width=22)\n\n\nprint(\n    text, panel\n)","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"you see? The panel and the text have the same width, BUT, the panel must fit its box, some padding and its content within the same width. So the size of the text inside will need to change compared to RenderableText(t; width=22). If we use a TextBox on the other hand:","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"\nimport Term: TextBox, Panel # hide\n\nt = \",\"^100 # hide\n\ntbox = TextBox(t, width=22)\npanel = Panel(t, width=22)\n\nprint(\n    tbox, panel\n)","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Now the two pieces of text look the same and the final layout is a lot more homogeneous, success!","category":"page"},{"location":"renderables/","page":"Renderables","title":"Renderables","text":"Let's move on to talk about layout more!","category":"page"},{"location":"api_color/","page":"Color","title":"Color","text":"CurrentModule = Term.color","category":"page"},{"location":"api_color/","page":"Color","title":"Color","text":"Pages   = [\"api_color.md\"]","category":"page"},{"location":"api_color/","page":"Color","title":"Color","text":"Modules = [color]","category":"page"},{"location":"api_color/#Term.color.ANSICode-Tuple{Any}","page":"Color","title":"Term.color.ANSICode","text":"ANSICode(color; bg::Bool=false)\n\nCreate ANSI tags for colors.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.AbstractColor","page":"Color","title":"Term.color.AbstractColor","text":"AbstractColor\n\nAbstract color type.\n\n\n\n\n\n","category":"type"},{"location":"api_color/#Term.color._rgb-Tuple{Any, Any}","page":"Color","title":"Term.color._rgb","text":"_rgb(numbertype, txt)\n\nTries to parse r,g,b out of a string based on number type.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color._rgb-Tuple{Any}","page":"Color","title":"Term.color._rgb","text":"_rgb(numbertype, txt)\n\nTries to parse r,g,b out of a string.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.chars-Tuple{AbstractString}","page":"Color","title":"Term.color.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.cleantext-Tuple{AbstractString}","page":"Color","title":"Term.color.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.do_by_line-Tuple{Function, AbstractString}","page":"Color","title":"Term.color.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.escape_brackets-Tuple{AbstractString}","page":"Color","title":"Term.color.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.get_color-Tuple{AbstractString}","page":"Color","title":"Term.color.get_color","text":"get_color(string::AbstractString; bg=false)::AbstractColor\n\nExtract a color type from a string with color information.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Color","title":"Term.color.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Color","title":"Term.color.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Color","title":"Term.color.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.hex2rgb-Tuple{AbstractString}","page":"Color","title":"Term.color.hex2rgb","text":"hex2rgb(hex::AbstractString)\n\nConverts a string hex color code to a RGB color\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.is_background-Tuple{AbstractString}","page":"Color","title":"Term.color.is_background","text":"is_background(string::AbstractString)::Bool\n\nCheck if a string represents background color information, of any type.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.is_color-Tuple{AbstractString}","page":"Color","title":"Term.color.is_color","text":"is_color(string::AbstractString)::Bool\n\nCheck if a string represents color information, of any type.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.is_hex_color-Tuple{AbstractString}","page":"Color","title":"Term.color.is_hex_color","text":"is_hex_color(string::AbstractString)::Bool\n\nCheck if a string represents a hex color.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.is_named_color-Tuple{AbstractString}","page":"Color","title":"Term.color.is_named_color","text":"is_named_color(string::AbstractString)::Bool\n\nCheck if a string represents a named color.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.is_rgb_color-Tuple{AbstractString}","page":"Color","title":"Term.color.is_rgb_color","text":"is_rgb_color(string::AbstractString)::Bool\n\nCheck if a string represents a RGB color.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.join_lines-Tuple{Any}","page":"Color","title":"Term.color.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.nospaces-Tuple{AbstractString}","page":"Color","title":"Term.color.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Color","title":"Term.color.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.reinsert_double_brackets-Tuple{AbstractString}","page":"Color","title":"Term.color.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.remove_ansi-Tuple{AbstractString}","page":"Color","title":"Term.color.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.remove_brackets-Tuple{AbstractString}","page":"Color","title":"Term.color.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.remove_markup-Tuple{AbstractString}","page":"Color","title":"Term.color.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.remove_markup_open-Tuple{AbstractString}","page":"Color","title":"Term.color.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.replace_double_brackets-Tuple{AbstractString}","page":"Color","title":"Term.color.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.replace_text","page":"Color","title":"Term.color.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_color/#Term.color.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Color","title":"Term.color.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.reshape_text-Tuple{AbstractString, Int64}","page":"Color","title":"Term.color.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.split_lines-Tuple{AbstractString}","page":"Color","title":"Term.color.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.split_lines-Tuple{Any}","page":"Color","title":"Term.color.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.square_to_round_brackets-Tuple{AbstractString}","page":"Color","title":"Term.color.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.textlen-Tuple{AbstractString}","page":"Color","title":"Term.color.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.truncate-Tuple{AbstractString, Int64}","page":"Color","title":"Term.color.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.unescape_brackets-Tuple{AbstractString}","page":"Color","title":"Term.color.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_color/#Term.color.unspace_commas-Tuple{AbstractString}","page":"Color","title":"Term.color.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_logging/","page":"Logging","title":"Logging","text":"CurrentModule = Term.logging","category":"page"},{"location":"api_logging/","page":"Logging","title":"Logging","text":"Pages   = [\"api_logging.md\"]","category":"page"},{"location":"api_logging/","page":"Logging","title":"Logging","text":"Modules = [logging]","category":"page"},{"location":"api_logging/#Term.logging.TermLogger","page":"Logging","title":"Term.logging.TermLogger","text":"TermLogger\n\nCustom logger type.\n\n\n\n\n\n","category":"type"},{"location":"api_logging/#Logging.handle_message-Tuple{Term.logging.TermLogger, Any, Any, Any, Any, Any, Any, Any}","page":"Logging","title":"Logging.handle_message","text":"Logging.handle_message(logger::TermLogger,\n\nHandle printing of log messages, with style!.\n\nIn addition to the log message and info such as file/line and time of log,  it prints kwargs styled by their type.\n\n\n\n\n\n","category":"method"},{"location":"api_logging/#Term.logging.install_term_logger","page":"Logging","title":"Term.logging.install_term_logger","text":"install_term_logger(theme::Theme=theme)\n\nInstall TermLogger as the global logging system.\n\ntheme::Theme can be passed to specify the theme to use for styling objects.\n\n\n\n\n\n","category":"function"},{"location":"api_logging/#Term.logging.print_closing_line","page":"Logging","title":"Term.logging.print_closing_line","text":"print_closing_line(color::String, width::Int)\n\nPrint the final line of a log message with style and date info\n\n\n\n\n\n","category":"function"},{"location":"api_segment/","page":"Segment","title":"Segment","text":"CurrentModule = Term.segment","category":"page"},{"location":"api_segment/","page":"Segment","title":"Segment","text":"Pages   = [\"api_segment.md\"]","category":"page"},{"location":"api_segment/","page":"Segment","title":"Segment","text":"Modules = [segment]","category":"page"},{"location":"api_segment/#Term.segment.Segment","page":"Segment","title":"Term.segment.Segment","text":"Segment\n\nstores one piece of text with all the styles applied to it.\n\n\n\n\n\n","category":"type"},{"location":"api_segment/#Term.segment.Segment-Tuple{Union{AbstractString, Term.segment.Segment}, Union{Nothing, AbstractString}}","page":"Segment","title":"Term.segment.Segment","text":"Segment(text::Union{Segment, AbstractString}, markup::AbstractString)\n\nConstruct a Segment out of a plain string and a markup string with style info\n\n\n\n\n\n","category":"method"},{"location":"api_segment/#Term.segment.Segment-Tuple{Union{AbstractString, Term.segment.Segment}, Union{Nothing, Term.style.MarkupStyle}}","page":"Segment","title":"Term.segment.Segment","text":"Segment(text::Union{Segment, AbstractString}, style::MarkupStyle)\n\nConstruct a Segment out of a plain string and a MarkupStyle object.\n\n\n\n\n\n","category":"method"},{"location":"api_segment/#Term.segment.Segment-Tuple{Union{AbstractString, Term.segment.Segment}}","page":"Segment","title":"Term.segment.Segment","text":"Segment(text::AbstractString)\n\nConstruct a Segment out of a string with markup.\n\n\n\n\n\n","category":"method"},{"location":"api_segment/#Base.:*-Tuple{Term.segment.Segment, AbstractString}","page":"Segment","title":"Base.:*","text":"concatenate strings and segments\n\n\n\n\n\n","category":"method"},{"location":"api_segment/#Base.show-Tuple{IO, Term.segment.Segment}","page":"Segment","title":"Base.show","text":"print styled in stdout, info otherwise\n\n\n\n\n\n","category":"method"},{"location":"api_measure/","page":"Measure","title":"Measure","text":"CurrentModule = Term.measure","category":"page"},{"location":"api_measure/","page":"Measure","title":"Measure","text":"Pages   = [\"api_measure.md\"]","category":"page"},{"location":"api_measure/","page":"Measure","title":"Measure","text":"Modules = [measure]","category":"page"},{"location":"api_measure/#Term.measure.Measure","page":"Measure","title":"Term.measure.Measure","text":"Measure\n\nStores the size of a piece of renderable material\n\n\n\n\n\n","category":"type"},{"location":"api_measure/#Term.measure.Measure-Tuple{AbstractString}","page":"Measure","title":"Term.measure.Measure","text":"Measure(str::String)\n\nConstructs a measure object from a string\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Base.:+-Tuple{Term.measure.Measure, Term.measure.Measure}","page":"Measure","title":"Base.:+","text":"The sum of measures returns a measure with the highest value along each dimension\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.chars-Tuple{AbstractString}","page":"Measure","title":"Term.measure.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.cleantext-Tuple{AbstractString}","page":"Measure","title":"Term.measure.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.do_by_line-Tuple{Function, AbstractString}","page":"Measure","title":"Term.measure.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.escape_brackets-Tuple{AbstractString}","page":"Measure","title":"Term.measure.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Measure","title":"Term.measure.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Measure","title":"Term.measure.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Measure","title":"Term.measure.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.join_lines-Tuple{Any}","page":"Measure","title":"Term.measure.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.nospaces-Tuple{AbstractString}","page":"Measure","title":"Term.measure.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Measure","title":"Term.measure.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.reinsert_double_brackets-Tuple{AbstractString}","page":"Measure","title":"Term.measure.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.remove_ansi-Tuple{AbstractString}","page":"Measure","title":"Term.measure.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.remove_brackets-Tuple{AbstractString}","page":"Measure","title":"Term.measure.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.remove_markup-Tuple{AbstractString}","page":"Measure","title":"Term.measure.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.remove_markup_open-Tuple{AbstractString}","page":"Measure","title":"Term.measure.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.replace_double_brackets-Tuple{AbstractString}","page":"Measure","title":"Term.measure.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.replace_text","page":"Measure","title":"Term.measure.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_measure/#Term.measure.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Measure","title":"Term.measure.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.reshape_text-Tuple{AbstractString, Int64}","page":"Measure","title":"Term.measure.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.split_lines-Tuple{AbstractString}","page":"Measure","title":"Term.measure.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.split_lines-Tuple{Any}","page":"Measure","title":"Term.measure.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.square_to_round_brackets-Tuple{AbstractString}","page":"Measure","title":"Term.measure.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.textlen-Tuple{AbstractString}","page":"Measure","title":"Term.measure.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.truncate-Tuple{AbstractString, Int64}","page":"Measure","title":"Term.measure.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.unescape_brackets-Tuple{AbstractString}","page":"Measure","title":"Term.measure.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_measure/#Term.measure.unspace_commas-Tuple{AbstractString}","page":"Measure","title":"Term.measure.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"styled_text/#Styled-text","page":"Styled text","title":"Styled text","text":"","category":"section"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"The term styled text refers to text printed out to a terminal (or other ::IO) with either color or other style (e.g., bold, italic) information. This is done by adding ANSI escape sequences in a string being printed to the terminal. These escape sequences are not rendered as caracters but add the style information.","category":"page"},{"location":"styled_text/#Style-macros","page":"Styled text","title":"Style macros","text":"","category":"section"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"The easiest way to add style information to a String in Term is using the dedicated macros:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"using Term\nprintln(@green \"this is green\")\nprintln(@blue \"and this is blue\")\nprint(\"\\n\")\nprintln(@bold \"this is bold\")\nprintln(@underline \"and this is underlined\")","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"For color you can use these macros: @black, @red, @green, @yellow, @blue, @magenta, @cyan, @white, @default. While for styling you have: @bold @dim @italic @underline.","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Note that the styling macros return a string, so you can combine the resulting strings as you would normally:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\nprintln(\n    @green(\"This is green\") * \" and \" * @red(\"this is red\")\n)\nprintln(\n    \"Make your text $(@underline(\"stand out\"))!\"\n)","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"With these style macros you can do some simply styling, but it gets clunky when you want to go beyond adding some color. Let's say you want you text to be blue, bold and underlined; do you really need to use three macros?","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Of course not, you can use the @style macro!","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\nmytext = @style \"this is my text\" blue bold underline\nprintln(mytext)","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Like the macros you already know, @style returns a string with the desired style, except that now you can specify multiple styles at once! ","category":"page"},{"location":"styled_text/#Markup-text","page":"Styled text","title":"Markup text","text":"","category":"section"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"The basic styling macros are great for handling simple cases where you just want to add a bit of style to a piece of text. More realistically, you might want more control about exactly which parts of your text have what style. ","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"As a way of example, let's say you want every other word of yours string:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"str=\"Every other word has colors!\"","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"to have a color. You could do it with macros:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\ne = @red \"Every\"\no = \"other\"\nw = @green \"word\"\nh = \"has\"\nc = @blue \"colors!\"\n\nprint(join((e, o, w, h, c), \" \"))","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"but that's awful. String interpolation would also not be of much help here. Instead, it would be great if we could specify styles directly inside a normal string and let Term figure it out.","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Well, that's exactly what we're going to do:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"import Term: tprint\ntprint(\n    \"[red]Every[/red] other [green]word[/green] has [blue]colors![/blue]\"\n)","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Woah! What just happened!! Two things happened: 1) Term styling machinery detects strings segments like \"[red]Every[/red]\" as meaning that the text between \"[...]\" and \"[/...]\" should be colored red and 2) tprint (short for term print) detects this style information and applies it to your text before printing. ","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Not bad huh? Even better, the style information inside a parentheses can be more than just color:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\ntprint(\n    \"[bold black underline on_red]So much [gold3 bold]STYLE[/gold3 bold] in this text[/bold black underline on_red]\"\n)","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"that's right, Term.jl can also color the background of your text (by adding on_C to your color C you set it as the background, see !!!! COLORS !!! page). Also, you might have noticed, Term can also handle nested style tags!","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"If you just want to use Term.jl's style functionality, just make sure to read the admonition below. If you're curious about what's happening under the hood, read on below!","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"warning: A note on style tags\nThe style tags used by Term.jl have an opening \"[style]\" and closing \"[/style]\" syntax. The style is applied to everything inbetween. For \"[/style]\" to close \"[style]\" the text in the parentheses must match exactly (excuding /), up to the number and position of spaces and the words order. So:\"[red] wohoo [/red]\"  # works\n\"[red] wohoo [/red ]\" # doesn't\n\"[bold blue] wohoo [/bold blue]\" # works\n\"[bold blue] wohoo [/blue bold]\" # doesn't","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"tip: Tip\nOccasionally you can do without the closing tag:tprint(\"[red]text\")Term.jl will add the closing tag to the end of the string for you. Generally though, when multiple styles are  applied to the same string, it's better to be explicit in exactly where each style starts and ends.","category":"page"},{"location":"styled_text/#Under-the-hood","page":"Styled text","title":"Under the hood","text":"","category":"section"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"If you're reading here you're curious about what exactly is happening under the hood. So let's get started. Term.jl, like rich in python, defines a simple markup language to specify the style of bits of strins. As we saw, the syntax is very simple with an opening and closing tag specifying the style and marking the start and end of the styled text. ","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"So the first thing that needs to happen is the detection of these markup tags. This is surprisingly hard because there's so many possible combinations. You can have markup tags whose style information varies considerably, you can have nested tags, you can have tags spread across lines and you can have nested tags spread across lines:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\ntprint(\n    \"\"\"\nAnd [blue] somehow\nit [bold red] all [/bold red]\nhas to [green underline] always\nwork [/green underline] correctly [/blue]\nsomehow.\n    \"\"\"\n)","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"CurrentModule = Term.markup","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"All of this is taken care of by Term.markup.extract_markup which returns a vector of Term.markup.MarkupTag objects. Each of these stores the opening and close tags (as SingleTag objects), the text inbetween them as well as a reference to all MarkupTags nested in it.","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"Normally, you should never use extract_markup directly. Instead you can let Term.style.apply_style handle it. When passed a String, apply_style will use extract_markup to extract style information before applying it to the string. This is done one MarkupTag at the time and recursively (i.e., dealing with nested tags before moving on to the next) until no markup information is found. ","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"After extracting style information, apply_style replaces the MarkupTag information with the appropriate ANSI escape codes. This is done by parsing the markup information (the text bewteen [...]) into a Term.style.MarkupStyle object which stores the style information. Finally, get_style_codes get the ANSI codes corresponding to the required style.  So in summary:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"apply_style(\"[red]text[/red]\")","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"will return a string with style information","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"import Term.style: apply_style  # hide\napply_style(\"[red]text[/red]\") # hide","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"which printed to the console looks like:","category":"page"},{"location":"styled_text/","page":"Styled text","title":"Styled text","text":"import Term.style: apply_style  # hide\nprint(apply_style(\"[red]text[/red]\")) # hide","category":"page"},{"location":"api_renderables/","page":"Renderables","title":"Renderables","text":"CurrentModule = Term.renderables","category":"page"},{"location":"api_renderables/","page":"Renderables","title":"Renderables","text":"Pages   = [\"api_renderables.md\"]","category":"page"},{"location":"api_renderables/","page":"Renderables","title":"Renderables","text":"Modules = [renderables]","category":"page"},{"location":"api_renderables/#Term.renderables.AbstractRenderable","page":"Renderables","title":"Term.renderables.AbstractRenderable","text":"AbstractRenderable\n\n\n\n\n\n","category":"type"},{"location":"api_renderables/#Term.renderables.Renderable","page":"Renderables","title":"Term.renderables.Renderable","text":"Renderable\n\nGeneric Renderable object.\n\n\n\n\n\n","category":"type"},{"location":"api_renderables/#Term.renderables.RenderableText","page":"Renderables","title":"Term.renderables.RenderableText","text":"RenderableText\n\nRenderable represnting a text.\n\nSee also Renderable, TextBox\n\n\n\n\n\n","category":"type"},{"location":"api_renderables/#Term.renderables.RenderableText-Tuple{AbstractString}","page":"Renderables","title":"Term.renderables.RenderableText","text":"RenderableText(text::AbstractString; width::Union{Nothing, Int, Symbol}=nothing)\n\nConstruct a RenderableText out of a string.\n\nIf a width is passed the text is resized to match the width.\n\n\n\n\n\n","category":"method"},{"location":"api_renderables/#Base.:+-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}, Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Renderables","title":"Base.:+","text":"Base.:+(r1::Union{AbstractString, AstractRenderable}, r2::Union{AbstractString, AstractRenderable})\n\nConcatenates two abstract rendereables\n\n\n\n\n\n","category":"method"},{"location":"api_renderables/#Base.string-Tuple{Term.renderables.AbstractRenderable}","page":"Renderables","title":"Base.string","text":"Base.string(r::AbstractRenderable)::String\n\nCreates a string representation of a renderable\n\n\n\n\n\n","category":"method"},{"location":"api_markup/","page":"Markup","title":"Markup","text":"CurrentModule = Term.markup","category":"page"},{"location":"api_markup/","page":"Markup","title":"Markup","text":"Pages   = [\"api_markup.md\"]","category":"page"},{"location":"api_markup/","page":"Markup","title":"Markup","text":"Modules = [markup]","category":"page"},{"location":"api_markup/#Term.markup.MarkupTag","page":"Markup","title":"Term.markup.MarkupTag","text":"MarkupTag\n\nRepresents a complete markup tag.\n\nIt stores two SingleTag, the text inbetween and any other MarkupTag that was detected in that text.\n\n\n\n\n\n","category":"type"},{"location":"api_markup/#Term.markup.SingleTag","page":"Markup","title":"Term.markup.SingleTag","text":"SingleTag\n\nRepresents a single tag [style] or [/style]\n\n\n\n\n\n","category":"type"},{"location":"api_markup/#Term.markup.SingleTag-Tuple{RegexMatch}","page":"Markup","title":"Term.markup.SingleTag","text":"SingleTag(match::RegexMatch)\n\nConstruct a SingleTag out of a RegexMatch\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.chars-Tuple{AbstractString}","page":"Markup","title":"Term.markup.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.clean_nested_tags-Tuple{AbstractString}","page":"Markup","title":"Term.markup.clean_nested_tags","text":"clean_nested_tags(text::AbstractString)::AbstractString\n\nGiven a text with nested string like: [red]aaaa [green]bbbb[/green] cccc [blue] ddddd [/blue]eeee[/red]\n\nit adds extra tags to ensure that text within inner tags is handled properly, giving: [red]aaaa [green]bbbb[/green][red] cccc [/red][blue] ddddd [/blue][red]eeee[/red]\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.clean_nested_tags-Tuple{Term.markup.MarkupTag, AbstractString}","page":"Markup","title":"Term.markup.clean_nested_tags","text":"clean_nested_tags(tag, text::AbstractString)\n\nrecursively applies to inner tags\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.cleantext-Tuple{AbstractString}","page":"Markup","title":"Term.markup.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.do_by_line-Tuple{Function, AbstractString}","page":"Markup","title":"Term.markup.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.escape_brackets-Tuple{AbstractString}","page":"Markup","title":"Term.markup.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.extract_markup-Tuple{AbstractString}","page":"Markup","title":"Term.markup.extract_markup","text":"extract_markup(input_text::AbstractString; firstonly=false)\n\nExtracts MarkupTags from a piece of text.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Markup","title":"Term.markup.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Markup","title":"Term.markup.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Markup","title":"Term.markup.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.has_markup-Tuple{AbstractString}","page":"Markup","title":"Term.markup.has_markup","text":"has_markup(text::AbstractString)\n\nReturns true if text includes a MarkupTag\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.join_lines-Tuple{Any}","page":"Markup","title":"Term.markup.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.nospaces-Tuple{AbstractString}","page":"Markup","title":"Term.markup.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.pairup_tags-Tuple{Vector{AbstractString}}","page":"Markup","title":"Term.markup.pairup_tags","text":"pairup_tags(text::Vector{AbstractString})\n\nGiven a vector of string with markup tags not properly closed/opened across lines,  it fixes things up.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Markup","title":"Term.markup.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.reinsert_double_brackets-Tuple{AbstractString}","page":"Markup","title":"Term.markup.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_ansi-Tuple{AbstractString}","page":"Markup","title":"Term.markup.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_brackets-Tuple{AbstractString}","page":"Markup","title":"Term.markup.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_markup-Tuple{AbstractString}","page":"Markup","title":"Term.markup.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.remove_markup_open-Tuple{AbstractString}","page":"Markup","title":"Term.markup.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.replace_double_brackets-Tuple{AbstractString}","page":"Markup","title":"Term.markup.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.replace_text","page":"Markup","title":"Term.markup.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_markup/#Term.markup.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Markup","title":"Term.markup.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.reshape_text-Tuple{AbstractString, Int64}","page":"Markup","title":"Term.markup.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.split_lines-Tuple{AbstractString}","page":"Markup","title":"Term.markup.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.split_lines-Tuple{Any}","page":"Markup","title":"Term.markup.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.square_to_round_brackets-Tuple{AbstractString}","page":"Markup","title":"Term.markup.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.textlen-Tuple{AbstractString}","page":"Markup","title":"Term.markup.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.truncate-Tuple{AbstractString, Int64}","page":"Markup","title":"Term.markup.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.unescape_brackets-Tuple{AbstractString}","page":"Markup","title":"Term.markup.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_markup/#Term.markup.unspace_commas-Tuple{AbstractString}","page":"Markup","title":"Term.markup.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_box/","page":"Box","title":"Box","text":"CurrentModule = Term.box","category":"page"},{"location":"api_box/","page":"Box","title":"Box","text":"Pages   = [\"api_box.md\"]","category":"page"},{"location":"api_box/","page":"Box","title":"Box","text":"Modules = [box]","category":"page"},{"location":"api_box/#Term.box.Box","page":"Box","title":"Term.box.Box","text":"Box\n\nDefines characters to render boxes.\n\nRow names:\n\n┌─┬┐ top │ ││ head ├─┼┤ headrow │ ││ mid ├─┼┤ row ├─┼┤ footrow │ ││ foot └─┴┘ bottom\n\neach row is an instance of BoxLine\n\n\n\n\n\n","category":"type"},{"location":"api_box/#Term.box.Box-Tuple{String, String}","page":"Box","title":"Term.box.Box","text":"Box(string)\n\nConstruct a Box objet out of a box string.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.BoxLine","page":"Box","title":"Term.box.BoxLine","text":"BoxLine\n\nStores the characters for a line of a Box object.\n\n\n\n\n\n","category":"type"},{"location":"api_box/#Term.box.chars-Tuple{AbstractString}","page":"Box","title":"Term.box.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.cleantext-Tuple{AbstractString}","page":"Box","title":"Term.box.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.do_by_line-Tuple{Function, AbstractString}","page":"Box","title":"Term.box.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.escape_brackets-Tuple{AbstractString}","page":"Box","title":"Term.box.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.fit-Tuple{Term.box.Box, Vector{Int64}}","page":"Box","title":"Term.box.fit","text":"fit(box::Box, widths::Vector{Int})::String\n\nCreates a box.\n\nThe box has one of each level type with columns widths specified by a vector of widhts.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Box","title":"Term.box.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Box","title":"Term.box.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.get_row-Tuple{Term.box.Box, Vector{Int64}, Symbol}","page":"Box","title":"Term.box.get_row","text":"get_row(box, [1, 2, 3], :row)\n\nGets characters for a row of a Box object.\n\nThe level Symbol can be used to specify the box level (:top, :footer...)\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.get_title_row-Tuple{Symbol, Term.box.Box, Union{Nothing, AbstractString}}","page":"Box","title":"Term.box.get_title_row","text":"gettitlerow(row::Symbol, box::Box, title::Union{Nothing, AbstractString}; <keyword arguments>)\n\nCreate a box row with a title string.\n\nCan create both titles in the top and bottom row to produce subtitles.\n\n#Arguments:\n\nwidth::Int: width of line\nstyle::Union{Nothing:  String}: style of line\ntitle_style::Union{Nothing:  AbstractString}: style of title string\njustify::Symbol=:left: position of title string\n\nSee also get_row.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Box","title":"Term.box.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.join_lines-Tuple{Any}","page":"Box","title":"Term.box.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.loop_last-Tuple{Vector{T} where T}","page":"Box","title":"Term.box.loop_last","text":"loop_last(v::Vector)\n\nReturns an iterable yielding tuples (is_last, value).\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.nospaces-Tuple{AbstractString}","page":"Box","title":"Term.box.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Box","title":"Term.box.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.reinsert_double_brackets-Tuple{AbstractString}","page":"Box","title":"Term.box.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.remove_ansi-Tuple{AbstractString}","page":"Box","title":"Term.box.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.remove_brackets-Tuple{AbstractString}","page":"Box","title":"Term.box.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.remove_markup-Tuple{AbstractString}","page":"Box","title":"Term.box.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.remove_markup_open-Tuple{AbstractString}","page":"Box","title":"Term.box.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.replace_double_brackets-Tuple{AbstractString}","page":"Box","title":"Term.box.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.replace_text","page":"Box","title":"Term.box.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_box/#Term.box.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Box","title":"Term.box.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.reshape_text-Tuple{AbstractString, Int64}","page":"Box","title":"Term.box.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.split_lines-Tuple{AbstractString}","page":"Box","title":"Term.box.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.split_lines-Tuple{Any}","page":"Box","title":"Term.box.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.square_to_round_brackets-Tuple{AbstractString}","page":"Box","title":"Term.box.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.textlen-Tuple{AbstractString}","page":"Box","title":"Term.box.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.truncate-Tuple{AbstractString, Int64}","page":"Box","title":"Term.box.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.unescape_brackets-Tuple{AbstractString}","page":"Box","title":"Term.box.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_box/#Term.box.unspace_commas-Tuple{AbstractString}","page":"Box","title":"Term.box.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_style/","page":"Style","title":"Style","text":"CurrentModule = Term.style","category":"page"},{"location":"api_style/","page":"Style","title":"Style","text":"Pages   = [\"api_style.md\"]","category":"page"},{"location":"api_style/","page":"Style","title":"Style","text":"Modules = [style]","category":"page"},{"location":"api_style/#Term.style.ANSICode-Tuple{Any}","page":"Style","title":"Term.style.ANSICode","text":"ANSICode(color; bg::Bool=false)\n\nCreate ANSI tags for colors.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.MarkupStyle","page":"Style","title":"Term.style.MarkupStyle","text":"MarkupStyle\n\nHolds information about the style specification set out by a MarkupTag.\n\n\n\n\n\n","category":"type"},{"location":"api_style/#Term.style.MarkupStyle-Tuple{Term.markup.MarkupTag}","page":"Style","title":"Term.style.MarkupStyle","text":"MarkupStyle(tag::MarkupTag)\n\nBuilds a MarkupStyle definition from a MarkupTag.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.apply_style-Tuple{AbstractString, Term.markup.MarkupTag}","page":"Style","title":"Term.style.apply_style","text":"apply_style(text::AbstractString, tag::MarkupTag)::AbstractString\n\nAppliy the style of a markup tag and it's nested tags\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.apply_style-Tuple{AbstractString, Term.style.MarkupStyle}","page":"Style","title":"Term.style.apply_style","text":"apply_style(text::AbstractString, style::MarkupStyle)::AbstractString\n\nApply a style to a text.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.apply_style-Tuple{AbstractString}","page":"Style","title":"Term.style.apply_style","text":"apply_style(text::AbstractString)\n\nExtract and apply all markup style in a string.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.chars-Tuple{AbstractString}","page":"Style","title":"Term.style.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.cleantext-Tuple{AbstractString}","page":"Style","title":"Term.style.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.do_by_line-Tuple{Function, AbstractString}","page":"Style","title":"Term.style.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.escape_brackets-Tuple{AbstractString}","page":"Style","title":"Term.style.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.extract_style-Tuple{AbstractString}","page":"Style","title":"Term.style.extract_style","text":"extract_style(text::AbstractString)\n\nExtract style information from a text.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Style","title":"Term.style.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Style","title":"Term.style.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.get_style_codes-Tuple{Term.style.MarkupStyle}","page":"Style","title":"Term.style.get_style_codes","text":"get_style_codes(style::MarkupStyle)\n\nGet ANSICodes corresponding to a MarkupStyle.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Style","title":"Term.style.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.join_lines-Tuple{Any}","page":"Style","title":"Term.style.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.nospaces-Tuple{AbstractString}","page":"Style","title":"Term.style.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Style","title":"Term.style.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.reinsert_double_brackets-Tuple{AbstractString}","page":"Style","title":"Term.style.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.remove_ansi-Tuple{AbstractString}","page":"Style","title":"Term.style.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.remove_brackets-Tuple{AbstractString}","page":"Style","title":"Term.style.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.remove_markup-Tuple{AbstractString}","page":"Style","title":"Term.style.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.remove_markup_open-Tuple{AbstractString}","page":"Style","title":"Term.style.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.replace_double_brackets-Tuple{AbstractString}","page":"Style","title":"Term.style.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.replace_text","page":"Style","title":"Term.style.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_style/#Term.style.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Style","title":"Term.style.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.reshape_text-Tuple{AbstractString, Int64}","page":"Style","title":"Term.style.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.split_lines-Tuple{AbstractString}","page":"Style","title":"Term.style.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.split_lines-Tuple{Any}","page":"Style","title":"Term.style.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.square_to_round_brackets-Tuple{AbstractString}","page":"Style","title":"Term.style.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.textlen-Tuple{AbstractString}","page":"Style","title":"Term.style.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.truncate-Tuple{AbstractString, Int64}","page":"Style","title":"Term.style.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.unescape_brackets-Tuple{AbstractString}","page":"Style","title":"Term.style.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_style/#Term.style.unspace_commas-Tuple{AbstractString}","page":"Style","title":"Term.style.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_panel/","page":"Panel","title":"Panel","text":"CurrentModule = Term.panel","category":"page"},{"location":"api_panel/","page":"Panel","title":"Panel","text":"Pages   = [\"api_panel.md\"]","category":"page"},{"location":"api_panel/","page":"Panel","title":"Panel","text":"Modules = [panel]","category":"page"},{"location":"api_panel/#Term.panel.Panel","page":"Panel","title":"Term.panel.Panel","text":"Panel\n\nRenderable with a panel surrounding some content:         ╭──────────╮         │ my panel │         ╰──────────╯\n\n\n\n\n\n","category":"type"},{"location":"api_panel/#Term.panel.Panel-Tuple","page":"Panel","title":"Term.panel.Panel","text":"Panel(renderables; kwargs...)\n\nPanel constructor for creating a panel out of multiple renderables at once.\n\n\n\n\n\n","category":"method"},{"location":"api_panel/#Term.panel.Panel-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Panel","title":"Term.panel.Panel","text":"Panel(\n    content::RenderablesUnion;\n    title::Union{Nothing, String}=nothing,\n    title_style::Union{String, Nothing}=nothing,\n    title_justify::Symbol=:left,\n    subtitle::Union{String, Nothing}=nothing,\n    subtitle_style::Union{String, Nothing}=nothing,\n    subtitle_justify::Symbol=:left,\n    width::Union{Nothing, Symbol, Int}=:fit,\n    height::Union{Nothing, Int}=nothing,\n    style::Union{String, Nothing}=nothing,\n    box::Symbol=:ROUNDED,\n    justify=:left\n)\n\nPanel constructor to fit a panel to a piece of (renderable) content.\n\ntitle can be used to specify a title to be addded to the top row and  title_style and title_justify set its appearance and position. Same for subtitle but for the panel's bottom row. width and height are used to set the Panel's size. If not passed they are computed to fit tot the content's size.\n\n\n\n\n\n","category":"method"},{"location":"api_panel/#Term.panel.TextBox","page":"Panel","title":"Term.panel.TextBox","text":"TextBox\n\nCreates a Panel and fits input text to it. The pannel is hidden so that the result is just a text box.\n\n\n\n\n\n","category":"type"},{"location":"api_panel/#Term.panel.TextBox-Tuple{Union{AbstractString, Vector{T} where T}}","page":"Panel","title":"Term.panel.TextBox","text":"TextBox(\n    text::Union{Vector, AbstractString};\n    width::Union{Nothing, Int}=nothing,\n    title::Union{Nothing, String}=nothing,\n    title_style::Union{String, Nothing}=\"default\",\n    title_justify::Symbol=:left,\n    subtitle::Union{String, Nothing}=nothing,\n    subtitle_style::Union{String, Nothing}=\"default\",\n    subtitle_justify::Symbol=:left,\n    justify::Symbol=:left,\n    fit::Symbol=:fit,\n    )\n\nCreates an hidden Panel with text in it.\n\nIf a width is passed, the input text is reshaped to have that size, unless fit=:truncate in which case it's cut to size. If no width is passed and fit=:fit the TextBox's size matches the size of the input text. Other arguments behave like Panel.\n\nSee also Panel.\n\n\n\n\n\n","category":"method"},{"location":"api_term/","page":"Term","title":"Term","text":"CurrentModule = Term","category":"page"},{"location":"api_term/","page":"Term","title":"Term","text":"Pages   = [\"api_term.md\"]","category":"page"},{"location":"api_term/","page":"Term","title":"Term","text":"Modules = [Term]","category":"page"},{"location":"api_term/#Term.ANSICode-Tuple{Any}","page":"Term","title":"Term.ANSICode","text":"ANSICode(color; bg::Bool=false)\n\nCreate ANSI tags for colors.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.CodeTheme","page":"Term","title":"Term.CodeTheme","text":"Custom hilighting theme for Highlighters.jl https://juliadocs.github.io/Highlights.jl/stable/man/theme/\n\n\n\n\n\n","category":"type"},{"location":"api_term/#Term.Theme","page":"Term","title":"Term.Theme","text":"Theme\n\nStores colors for different semantically relevant items, used to  style outputs to terminal.\n\n\n\n\n\n","category":"type"},{"location":"api_term/#Term.measure.Measure-Tuple{Term.segment.Segment}","page":"Term","title":"Term.measure.Measure","text":"Measure(seg::Segment)\n\ngives the measure of a segment\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.measure.Measure-Tuple{Vector{Term.segment.Segment}}","page":"Term","title":"Term.measure.Measure","text":"Measure(segments::Vector{Segment})\n\ngives the measure of a vector of segments\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Highlights.Format.render-Tuple{IO, MIME{Symbol(\"text/ansi\")}, Highlights.Format.TokenIterator}","page":"Term","title":"Highlights.Format.render","text":"Format.render(io::IO, ::MIME\"text/ansi\", tokens::Format.TokenIterator)\n\ncustom ANSI lexer for Highlighters.jl\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.chars-Tuple{AbstractString}","page":"Term","title":"Term.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.cleantext-Tuple{AbstractString}","page":"Term","title":"Term.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.do_by_line-Tuple{Function, AbstractString}","page":"Term","title":"Term.do_by_line","text":"do_by_line(fn::Function, text::AbstractString)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::AbstractString argument.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.escape_brackets-Tuple{AbstractString}","page":"Term","title":"Term.escape_brackets","text":"remove_ansi(str::AbstractString)::AbstractString\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.get_last_valid_str_idx-Tuple{AbstractString, Int64}","page":"Term","title":"Term.get_last_valid_str_idx","text":"get_last_valid_str_idx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the last valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.get_next_valid_str_idx-Tuple{AbstractString, Int64}","page":"Term","title":"Term.get_next_valid_str_idx","text":"getnextvalidstridx(str::AbstractString, idx::Int)\n\nGet valid index to cut a string at.\n\nWhen indexing a string, the number of indices is given by the the sum of the ncodeunits of each Char, but some indices will not be valid. This function ensures that given a (potentially) not valid index, the next valid one is elected.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.get_valid_chars!-Tuple{Vector{Int64}, Any, Int64}","page":"Term","title":"Term.get_valid_chars!","text":"get_valid_chars!(valid_chars::Vector{Int}, tag, δ::Int)\n\nRecursively extract valid characters (i.e. not in markup tags) from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.highlight-Tuple{AbstractString, Term.Theme, Symbol}","page":"Term","title":"Term.highlight","text":"highlight(text::AbstractString, theme::Theme, like::Symbol)\n\nHilights an entire text as if it was a type of semantically relevant text of type :like.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.highlight-Tuple{AbstractString, Term.Theme}","page":"Term","title":"Term.highlight","text":"highlight(text::AbstractString, theme::Theme)\n\nHighlighs a text introducing markup to style semantically relevant segments, colors specified by a theme object\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.highlight_syntax-Tuple{AbstractString}","page":"Term","title":"Term.highlight_syntax","text":"highlight_syntax(code::AbstractString; style::Bool=true)\n\nHighlight Julia code syntax in a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.join_lines-Tuple{Any}","page":"Term","title":"Term.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.load_code_and_highlight-Tuple{AbstractString, Int64}","page":"Term","title":"Term.load_code_and_highlight","text":"load_code_and_highlight(path::AbstractString, lineno::Int; δ::Int=3, width::INt=120)\n\nLoad a file, get the code and format it. Return styled text\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.nospaces-Tuple{AbstractString}","page":"Term","title":"Term.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Term","title":"Term.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.reinsert_double_brackets-Tuple{AbstractString}","page":"Term","title":"Term.reinsert_double_brackets","text":"reinsert_double_brackets(text::AbstractString)::AbstractString\n\nInsert previously replaced double brackets\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_ansi-Tuple{AbstractString}","page":"Term","title":"Term.remove_ansi","text":"remove_ansi(str::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_brackets-Tuple{AbstractString}","page":"Term","title":"Term.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_markup-Tuple{AbstractString}","page":"Term","title":"Term.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.remove_markup_open-Tuple{AbstractString}","page":"Term","title":"Term.remove_markup_open","text":"remove_markup_open(text::AbstractString)\n\nRemove all opening markup tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.replace_double_brackets-Tuple{AbstractString}","page":"Term","title":"Term.replace_double_brackets","text":"replace_double_brackets(text::AbstractString)::AbstractString\n\nReplace double brackets with %% and ±± to avoid them being picked up by markup extraction\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.replace_text","page":"Term","title":"Term.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api_term/#Term.replace_text-Tuple{AbstractString, Int64, Int64, AbstractString}","page":"Term","title":"Term.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.reshape_text-Tuple{AbstractString, Int64}","page":"Term","title":"Term.reshape_text","text":"reshape_text(text::AbstractString, width::Int)\n\nReshape text to have a given width.\n\nWhen text is longer than width, it gets cut into multiple lines. This is done carefully to preserve style information by: avoiding  cutting inside style markup and copying markup tags over to new lines so that the style is correctly applied.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.split_lines-Tuple{AbstractString}","page":"Term","title":"Term.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.split_lines-Tuple{Any}","page":"Term","title":"Term.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.square_to_round_brackets-Tuple{AbstractString}","page":"Term","title":"Term.square_to_round_brackets","text":"square_to_round_brackets(text::AbstractString)\n\nReplace square brackets with round ones.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.textlen-Tuple{AbstractString}","page":"Term","title":"Term.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.truncate-Tuple{AbstractString, Int64}","page":"Term","title":"Term.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.unescape_brackets-Tuple{AbstractString}","page":"Term","title":"Term.unescape_brackets","text":"unescape_brackets(text::AbstractString)::AbstractString\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.unspace_commas-Tuple{AbstractString}","page":"Term","title":"Term.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api_term/#Term.@make_color_macro-Tuple{Any}","page":"Term","title":"Term.@make_color_macro","text":"Macro to create macros such as @green which colors text accordingly\n\n\n\n\n\n","category":"macro"},{"location":"api_term/#Term.@make_mode_macro-Tuple{Any}","page":"Term","title":"Term.@make_mode_macro","text":"Macro to create macros such as @underline which styles text accordingly.\n\n\n\n\n\n","category":"macro"},{"location":"api_term/#Term.@style-Tuple{Any, Vararg{Any, N} where N}","page":"Term","title":"Term.@style","text":"@style \"text\" style1 style2...\n\nApplies a sequence of styles to a piece of text, such that\n\nprintln(@style \"my text\" bold green underline)\n\nwill print my text as bold, green and underlined\n\n\n\n\n\n","category":"macro"},{"location":"api_inspect/","page":"Inspect","title":"Inspect","text":"CurrentModule = Term.inspect","category":"page"},{"location":"api_inspect/","page":"Inspect","title":"Inspect","text":"Modules = [introspection]","category":"page"},{"location":"api_console/","page":"Console","title":"Console","text":"CurrentModule = Term.console","category":"page"},{"location":"api_console/","page":"Console","title":"Console","text":"Modules = [consoles]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Term","category":"page"},{"location":"","page":"Home","title":"Home","text":"Term.jl is a Julia library for producing, styled and beautiful terminal output, like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Term\nprint(Term.make_logo())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Term.jl uses a simple markup syntax to add style information to standard Julia strings. It also provides Renderable objects such as the Panels and TextBoxes that you can see in the example below. These too can be styled, and include styled text, but more importantly they can benested and stacked to produce structured visual displays in your terminal. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In a Julia script:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkd\n\nPkg.add(\"Term\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or in the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]  # enters the pkg interface\npkg> add Term","category":"page"},{"location":"","page":"Home","title":"Home","text":"done!","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rest of the documentation is dedicated to explaining the basic concepts behavind Term.jl and how to use Term to produce styled terminal text.  Head to the GitHub repository to find several detailed examples or jump in the Discussions to start chatting with us. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"!!! note \"A note on Rich     Term.jl is based on a pre-existing package called rich (see here) developed by Will McGugan.     While most of how Term.jl handles things under the hood is specific to Term, the basic concepts behind how to even begin creating fancy terminal     outputs like the ones that rich and Term can produce are entirely Will's work. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We're very thankful to Will for making `rich`'s code open soruce and for the help and encouragement during the development of `Term`.","category":"page"}]
}
