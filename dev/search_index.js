var documenterSearchIndex = {"docs":
[{"location":"api/api_color/#Color","page":"Color","title":"Color","text":"","category":"section"},{"location":"api/api_color/","page":"Color","title":"Color","text":"CurrentModule = Term.color","category":"page"},{"location":"api/api_color/","page":"Color","title":"Color","text":"Pages   = [\"api_color.md\"]","category":"page"},{"location":"api/api_color/","page":"Color","title":"Color","text":"Modules = [color]","category":"page"},{"location":"api/api_color/#Term.ANSICode-Tuple{Term.color.NamedColor}","page":"Color","title":"Term.ANSICode","text":"ANSICode(color; bg::Bool=false)\n\nCreate ANSI tags for colors.\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.AbstractColor","page":"Color","title":"Term.color.AbstractColor","text":"AbstractColor\n\nAbstract color type.\n\n\n\n\n\n","category":"type"},{"location":"api/api_color/#Term.color.get_color-Tuple{Any}","page":"Color","title":"Term.color.get_color","text":"get_color(string::String; bg=false)::AbstractColor\n\nExtract a color type from a string with color information.\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.hex2rgb-Tuple{Any}","page":"Color","title":"Term.color.hex2rgb","text":"hex2rgb(hex::String)\n\nConverts a string hex color code to a RGB color\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.is_background-Tuple{Any}","page":"Color","title":"Term.color.is_background","text":"is_background(string::String)::Bool\n\nCheck if a string represents background color information, of any type.\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.is_color-Tuple{Any}","page":"Color","title":"Term.color.is_color","text":"is_color(string::String)::Bool\n\nCheck if a string represents color information, of any type.\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.is_hex_color-Tuple{Any}","page":"Color","title":"Term.color.is_hex_color","text":"is_hex_color(string::String)::Bool\n\nCheck if a string represents a hex color.\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.is_named_color-Tuple{Any}","page":"Color","title":"Term.color.is_named_color","text":"is_named_color(string::String)::Bool\n\nCheck if a string represents a named color.\n\n\n\n\n\n","category":"method"},{"location":"api/api_color/#Term.color.is_rgb_color-Tuple{Any}","page":"Color","title":"Term.color.is_rgb_color","text":"is_rgb_color(string::String)::Bool\n\nCheck if a string represents a RGB color.\n\n\n\n\n\n","category":"method"},{"location":"adv/introspection/#Introspection","page":"Introspection","title":"Introspection","text":"","category":"section"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"If you often use the (awesome) Julia REPL, you'll be familiar witht he fact that you can type ? to enter the docs section. Then typing a name (e.g., of a Type or function) will bring up the relevant docs. E.g. you might get something like this:","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"help?> cat\nsearch: cat catch catch_backtrace vcat hcat hvcat hvncat CartesianIndex CartesianIndices CapturedException truncate @allocated @deprecate broadcast Broadcast broadcast! IndexCartesian\n\n  cat(A...; dims)\n\n  Concatenate the input arrays along the specified dimensions in the iterable dims. For dimensions not in dims, all input arrays should have the same size, which will also be the\n  size of the output array along that dimension. For dimensions in dims, the size of the output array is the sum of the sizes of the input arrays along that dimension. If dims is a\n  single number, the different arrays are tightly stacked along that dimension. If dims is an iterable containing several dimensions, this allows one to construct block diagonal\n  matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example,\n  cat(matrices...; dims=(1,2)) builds a block diagonal matrix, i.e. a block matrix with matrices[1], matrices[2], ... as diagonal blocks and matching zero blocks away from the\n  diagonal.\n\n  See also hcat, vcat, hvcat, repeat.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> cat([1 2; 3 4], [pi, pi], fill(10, 2,3,1); dims=2)\n  2×6×1 Array{Float64, 3}:\n  [:, :, 1] =\n   1.0  2.0  3.14159  10.0  10.0  10.0\n   3.0  4.0  3.14159  10.0  10.0  10.0\n  \n  julia> cat(true, trues(2,2), trues(4)', dims=(1,2))\n  4×7 Matrix{Bool}:\n   1  0  0  0  0  0  0\n   0  1  1  0  0  0  0\n   0  1  1  0  0  0  0\n   0  0  0  1  1  1  1","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"This is super useful, you can get access to the docs directly in your console without having to go google stuff. But, if you're on Terms docs you're likely after a more stylish terminal experience. Can we do something like what ? print does in the REPL, but with Term's styling? Of course we can:","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"import Term: inspect\n\ninspect(cat)","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"So given a function name, inspect prints out docstrings as well as methods signature. Just like ? vec but with panels and colors. But it can also work with Types:","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"import Term: inspect\n\nabstract type AbstractType end\n\n\"\"\"\n    MyType\n\nJust a type.\n\"\"\"\nstruct MyType <: AbstractType\n    x::Int\n    y::String\nend\n\n\"\"\"\n    Mytype(x::Int)\n\nConstruct MyType with only an `Int`\n\"\"\"\nMyType(x::Int) = MyType(x, \"no string\")\n\n\"\"\"\n    do_a_thing(a::MyType, x)\n\nFunction doing something with MyType\n\"\"\"\ndo_a_thing(a::MyType, x) = print(a, x)\ndo_a_thing(a::MyType, x::MyType) = println(a, x)\n\n# ! now inspect\ninspect(MyType)","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"warning: Warning\nOoooops. It looks like the layout is a bit funky when rendered in the docs! It will look fine when you use Term in your REPL.","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"As you can see, with a DataType argument, inspect shows you the type's hierarchy for MyType, its docstring and where is defined as well as constructors for our custom type and methods that make use of MyType in their arguments. That's pretty much it, enjoy using inspect!","category":"page"},{"location":"adv/introspection/","page":"Introspection","title":"Introspection","text":"note: Note\ninspect accepts an optional keyword argument to choose how many constructors and methods to show: max_n_methods::Int. If an object has loads of methods, only the first max_n_methods will be shown.","category":"page"},{"location":"ren/panel/#PanelDocs","page":"Panel","title":"Panel","text":"","category":"section"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"Okay, time to move beyond simple text. It's time for:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"import Term: Panel # hide\nprint(# hide\n    Panel(# hide\n        \"[red]awesome[/red]\", # hide\n        title=\"Term's\", # hide\n        title_style=\"bold green\", # hide\n        style=\"gold1 bold\", # hide\n        subtitle=\"Panels\", # hide\n        subtitle_style=\"bold blue\", # hide\n        subtitle_justify=:right, # hide\n        width=18, # hide\n        justify=:center # hide\n    ) # hide\n) # hide","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"Simply put, a Panel shows a piece of content (generally a styled string, but it can be any Renderable really) surrounded by a box. Simple but effective.","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"Well not that simple actually because Term.panel.Panel is the first renderable that allows you lots of options to personalize its appearance. For instance the panel printed above is given by:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"    Panel(\n        \"[red]awesome[/red]\",\n        title=\"Term's\",\n        title_style=\"bold green\",\n        style=\"gold1 bold\",\n        subtitle=\"Panels\",\n        subtitle_style=\"bold blue\",\n        subtitle_justify=:right,\n        width=18,\n        justify=:center\n    )","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"The first argument is the content, the rest is styling options. As you can see you can specify the titles and subtitles (or leave them out if you prefer, do your thing!), their appearance (via markup style information) and their position (:left, :center or :right). The style argument sets the style of the box itself (and title/subtitle if they don't have dedicated style information).","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"The box is created using Term's own Box type! It's not worth going too much into exactly how it works, but it's worth pointing out that there's loads of types of boxes:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"ASCII,\nASCII2,\nASCII_DOUBLE_HEAD,\nSQUARE,\nSQUARE_DOUBLE_HEAD,\nMINIMAL,\nMINIMAL_HEAVY_HEAD\nMINIMAL_DOUBLE_HEAD,\nSIMPLE,\nSIMPLE_HEAD,\nSIMPLE_HEAVY,\nHORIZONTALS,\nROUNDED,\nHEAVY\nHEAVY_EDGE,\nHEAVY_HEAD,\nDOUBLE,\nDOUBLE_EDGE","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"And you can use any of these with your panels:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"import Term: Panel\n\nprint(\n    Panel(width=8, box=:DOUBLE, style=\"green\") *\n    Panel(width=8, box=:HEAVY, style=\"white\") *\n    Panel(width=8, box=:ROUNDED, style=\"red\"),\n)","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"Let's look at some more examples:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"\nprint(\n    Panel(\"this panel has fixed width, text on the left\"; width = 66, justify = :left),    \n    Panel(\"this one too, but the text is at the center!\"; width = 66, justify = :center),\n    Panel(\"the text is here!\"; width = 66, justify = :right),\n)\nprint(\"\\n\")\n\nprint(\n    Panel(\"Titles have style too!!\"; width = 60, justify = :center, title=\"My Title\", title_style=\"red bold\", title_justify=:right, subtitle=\"Made with Term\", subtitle_style=\"dim\", subtitle_justify=:left)\n)\n","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"By the way, Panels are not limited to having strings as content, they can have other renderables too (multiple ones in fact)!","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"print(\n    Panel(\n        Panel(width=18, style=\"green\"),\n        Panel(width=18, style=\"white\"),\n        Panel(width=18, style=\"red\"),\n        title=\"so many panels!\",\n        fit=true,\n        title_justify=:left,\n        title_style=\"bold red\"\n    )\n)","category":"page"},{"location":"ren/panel/#Size-and-fitting","page":"Panel","title":"Size & fitting","text":"","category":"section"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"By default Panels are created to be 88 in width (or less if you have a small terminal) and as high as required to fit your content (+2 for the top and bottom line). If you content is narrowe than the panel's width, then all is good (and you can use justify to place it as you like). If not, there's two options: reshape your text to fit in the panel or enlarge the panel to envelop your content. The first is used when the content is a text type, the latter if its another renderable:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"\nreshaped = Panel(\"very long text\"^24)\n\nprint(\n    reshaped,\n    Panel(reshaped)\n)","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"If you want to though, you can set the size to be whatever you like:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"print(\n    Panel(; width=22, height=9)\n)","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"Sometimes though, you just want your panel to snugly envelop your content without extra space and without having to specify the width. Easy:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"\np = Panel(; width=22, height=4)\nprint(\n    Panel(p; fit=true)\n)","category":"page"},{"location":"ren/panel/#Padding","page":"Panel","title":"Padding","text":"","category":"section"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"You'll notice in the example above that there's still some space around our nested panel, even though we wanted fit=true, why is that? Well, Panel by default applies some Padding around your content. You can control how much padding you want:","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"\nprint(\n    Panel(p; fit=true, padding=(0, 0, 0, 0)),\n    Panel(p; fit=true, padding=(3, 3, 3, 3)),\n)","category":"page"},{"location":"ren/panel/","page":"Panel","title":"Panel","text":"The syntax is (left, right, top, bottom) and the default is (2, 2, 0, 0).","category":"page"},{"location":"api/api_box/#Box","page":"Box","title":"Box","text":"","category":"section"},{"location":"api/api_box/","page":"Box","title":"Box","text":"CurrentModule = Term.box","category":"page"},{"location":"api/api_box/","page":"Box","title":"Box","text":"Pages   = [\"api_box.md\"]","category":"page"},{"location":"api/api_box/","page":"Box","title":"Box","text":"Modules = [box]","category":"page"},{"location":"api/api_box/#Term.box.Box","page":"Box","title":"Term.box.Box","text":"Box\n\nDefines characters to render boxes.\n\nRow names:\n\n┌─┬┐ top │ ││ head ├─┼┤ headrow │ ││ mid ├─┼┤ row ├─┼┤ footrow │ ││ foot └─┴┘ bottom\n\neach row is an instance of BoxLine\n\n\n\n\n\n","category":"type"},{"location":"api/api_box/#Term.box.Box-Tuple{String, String}","page":"Box","title":"Term.box.Box","text":"Box(string)\n\nConstruct a Box objet out of a box string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_box/#Term.box.BoxLine","page":"Box","title":"Term.box.BoxLine","text":"BoxLine\n\nStores the characters for a line of a Box object.\n\n\n\n\n\n","category":"type"},{"location":"api/api_box/#Term.box.fit-Tuple{Term.box.Box, Vector{Int64}}","page":"Box","title":"Term.box.fit","text":"fit(box::Box, widths::Vector{Int})::String\n\nCreates a box.\n\nThe box has one of each level type with columns widths specified by a vector of widhts.\n\n\n\n\n\n","category":"method"},{"location":"api/api_box/#Term.box.get_lrow-Tuple{Term.box.Box, Int64, Symbol}","page":"Box","title":"Term.box.get_lrow","text":"get_lrow(box::Box, width::Int, level::Symbol)::String\n\nGet a box's row's left part (no righ char)\n\nGet a box's row's right part (no left char) See also get_row, get_rrow.\n\n\n\n\n\n","category":"method"},{"location":"api/api_box/#Term.box.get_row-Tuple{Term.box.Box, Int64, Symbol}","page":"Box","title":"Term.box.get_row","text":"get_row(box::Box, width::Int, level::Symbol)::String\n\nGet a box's row of given width.\n\n\n\n\n\n","category":"method"},{"location":"api/api_box/#Term.box.get_row-Tuple{Term.box.Box, Vector{Int64}, Symbol}","page":"Box","title":"Term.box.get_row","text":"get_row(box, [1, 2, 3], :row)\n\nGets characters for a row of a Box object.\n\nThe level Symbol can be used to specify the box level (:top, :footer...). The total width will be the sum of the widths +2\n\n\n\n\n\n","category":"method"},{"location":"api/api_box/#Term.box.get_rrow-Tuple{Term.box.Box, Int64, Symbol}","page":"Box","title":"Term.box.get_rrow","text":"get_rrow(box::Box, width::Int, level::Symbol)::String\n\nGet a box's row's right part (no left char) See also get_row, get_lrow.\n\n\n\n\n\n","category":"method"},{"location":"api/api_box/#Term.box.get_title_row-Tuple{Symbol, Any, Union{Nothing, String}}","page":"Box","title":"Term.box.get_title_row","text":"gettitlerow(row::Symbol, box::Box, title::Union{Nothing, AbstractString}; <keyword arguments>)\n\nCreate a box row with a title string.\n\nCan create both titles in the top and bottom row to produce subtitles.\n\n#Arguments:\n\nwidth::Int: width of line\nstyle::String: style of line\ntitle_style::String: style of title string\njustify::Symbol=:left: position of title string\n\nSee also get_row.\n\n\n\n\n\n","category":"method"},{"location":"api/api_errors/#Errors","page":"Errors","title":"Errors","text":"","category":"section"},{"location":"api/api_errors/","page":"Errors","title":"Errors","text":"CurrentModule = Term.errors","category":"page"},{"location":"api/api_errors/","page":"Errors","title":"Errors","text":"Pages   = [\"api_errors.md\"]","category":"page"},{"location":"api/api_errors/","page":"Errors","title":"Errors","text":"Modules = [errors]","category":"page"},{"location":"api/api_errors/#Term.errors._highlight","page":"Errors","title":"Term.errors._highlight","text":"_highlight(x)\n\nApply style to x based on its type.\n\n\n\n\n\n","category":"function"},{"location":"api/api_errors/#Term.errors._highlight_numbers-Tuple{AbstractString}","page":"Errors","title":"Term.errors._highlight_numbers","text":"_highlight_numbers(x::AbstractString)\n\nAdd style to each number in a string\n\n\n\n\n\n","category":"method"},{"location":"api/api_errors/#Term.errors._highlight_with_type-Tuple{Any}","page":"Errors","title":"Term.errors._highlight_with_type","text":"_highlight_with_type(x)\n\nApply style to x and and mark its type.\n\n\n\n\n\n","category":"method"},{"location":"api/api_errors/#Term.errors.backtrace_subpanel-Tuple{String, Int64, String}","page":"Errors","title":"Term.errors.backtrace_subpanel","text":"backtrace_subpanel(line::String, WIDTH::Int, title::String)\n\nCreate a subpanel for stacktrace, showing source code.\n\n\n\n\n\n","category":"method"},{"location":"api/api_errors/#Term.errors.style_backtrace-Tuple{IO, Vector}","page":"Errors","title":"Term.errors.style_backtrace","text":"style_backtrace(io::IO, t::Vector)\n\nCreate a Panel with styled error backtrace information.\n\n\n\n\n\n","category":"method"},{"location":"api/api_errors/#Term.errors.style_error-Tuple{IO, Any}","page":"Errors","title":"Term.errors.style_error","text":"style_error(io::IO, er)\n\nCreate a style error panel.\n\nCreates a Panel with an error message and optional hints.\n\n\n\n\n\n","category":"method"},{"location":"api/api_errors/#Term.errors.style_stacktrace_simple-Tuple{Vector}","page":"Errors","title":"Term.errors.style_stacktrace_simple","text":"style_stacktrace_simple(stack::Vector)\n\nSimply style a stacktrace. Just adding a miniumum of color.\n\n\n\n\n\n","category":"method"},{"location":"api/api_measure/#Measure","page":"Measure","title":"Measure","text":"","category":"section"},{"location":"api/api_measure/","page":"Measure","title":"Measure","text":"CurrentModule = Term.measure","category":"page"},{"location":"api/api_measure/","page":"Measure","title":"Measure","text":"Pages   = [\"api_measure.md\"]","category":"page"},{"location":"api/api_measure/","page":"Measure","title":"Measure","text":"Modules = [measure]","category":"page"},{"location":"api/api_measure/#Term.measure.Measure","page":"Measure","title":"Term.measure.Measure","text":"Measure\n\nStores the size of a piece of renderable material\n\n\n\n\n\n","category":"type"},{"location":"api/api_measure/#Term.measure.Measure-Tuple{AbstractString}","page":"Measure","title":"Term.measure.Measure","text":"Measure(str::String)\n\nConstructs a measure object from a string\n\n\n\n\n\n","category":"method"},{"location":"api/api_measure/#Base.:+-Tuple{Term.measure.Measure, Term.measure.Measure}","page":"Measure","title":"Base.:+","text":"The sum of measures returns a measure with the highest value along each dimension\n\n\n\n\n\n","category":"method"},{"location":"api/api_measure/#Term.measure.height","page":"Measure","title":"Term.measure.height","text":"height\n\nMeasure the height of renderable objects (text, AbsstractRenderable)\n\n\n\n\n\n","category":"function"},{"location":"api/api_measure/#Term.measure.width","page":"Measure","title":"Term.measure.width","text":"width\n\nMeasure the width of renderable objects (text, AbsstractRenderable)\n\n\n\n\n\n","category":"function"},{"location":"basics/styled_text/#Styled-text","page":"Styled text","title":"Styled text","text":"","category":"section"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"The term styled text refers to text printed out to a terminal (or other ::IO) with either color or other style (e.g., bold, italic) information. This is done by adding ANSI escape sequences in a string being printed to the terminal. These escape sequences are not rendered as caracters but add the style information.","category":"page"},{"location":"basics/styled_text/#Style-macros","page":"Styled text","title":"Style macros","text":"","category":"section"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"The easiest way to add style information to a String in Term is using the dedicated macros:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"using Term\nprintln(@green \"this is green\")\nprintln(@blue \"and this is blue\")\nprint(\"\\n\")\nprintln(@bold \"this is bold\")\nprintln(@underline \"and this is underlined\")","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"To color you can use these macros: @black, @red, @green, @yellow, @blue, @magenta, @cyan, @white, @default. While for styling you have: @bold @dim @italic @underline.","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Note that the styling macros return a string, so you can combine the resulting strings as you would normally:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\nprintln(\n    @green(\"This is green\") * \" and \" * @red(\"this is red\")\n)\nprintln(\n    \"Make your text $(@underline(\"stand out\"))!\"\n)","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"With these style macros you can do some simply styling, but it gets clunky when you want to go beyond adding some color. Let's say you want you text to be blue, bold and underlined; do you really need to use three macros?","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Of course not, you can use the @style macro!","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\nmytext = @style \"this is my text\" blue bold underline\nprintln(mytext)","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Like the macros you already know, @style returns a string with the desired style, except that now you can specify multiple styles at once! ","category":"page"},{"location":"basics/styled_text/#Markup-text","page":"Styled text","title":"Markup text","text":"","category":"section"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"The basic styling macros are great for handling simple cases where you just want to add a bit of style to a piece of text. More realistically, you might want more control about exactly which parts of your text have what style. ","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"As a way of example, let's say you want every other word of yours string:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"str=\"Every other word has colors!\"","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"to have a color. You could do it with macros:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\ne = @red \"Every\"\no = \"other\"\nw = @green \"word\"\nh = \"has\"\nc = @blue \"colors!\"\n\nprint(join((e, o, w, h, c), \" \"))","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"but that's awful. String interpolation would also not be of much help here. Instead, it would be great if we could specify styles directly inside a normal string and let Term figure it out.","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Well, that's exactly what we're going to do:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"import Term: tprint\ntprint(\n    \"[red]Every[/red] other [green]word[/green] has [blue]colors![/blue]\"\n)","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Woah! What just happened!! Two things happened: 1) Term styling machinery detects strings segments like \"[red]Every[/red]\" as meaning that the text between \"[...]\" and \"[/...]\" should be colored red and 2) tprint (short for term print) detects this style information and applies it to your text before printing. ","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Not bad huh? Even better, the style information inside a parentheses can be more than just color:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\ntprint(\n    \"[bold black underline on_red]So much [gold3 bold]STYLE[/gold3 bold] in this text[/bold black underline on_red]\"\n)","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"that's right, Term.jl can also color the background of your text (by adding on_C to your color C you set it as the background, see colors page). As you can see you can pass multiple style information tags as space separated words within the \"[...]\". Also, you might have noticed, Term can also handle nested style tags!","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"If you just want to use Term.jl's style functionality, just make sure to read the admonition below. If you're curious about what's happening under the hood, read on below!","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"warning: A note on style tags\nThe style tags used by Term.jl have an opening \"[style]\" and closing \"[/style]\" syntax. The style is applied to everything inbetween. For \"[/style]\" to close \"[style]\" the text in the parentheses must match exactly (excuding /), up to the number and position of spaces and the words order. So:\"[red] wohoo [/red]\"  # works\n\"[red] wohoo [/red ]\" # doesn't\n\"[bold blue] wohoo [/bold blue]\" # works\n\"[bold blue] wohoo [/blue bold]\" # doesn't","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"tip: Tip\nOccasionally you can do without the closing tag:tprint(\"[red]text\")Term.jl will add the closing tag to the end of the string for you. Generally though, when multiple styles are  applied to the same string, it's better to be explicit in exactly where each style starts and ends.","category":"page"},{"location":"basics/styled_text/#Under-the-hood","page":"Styled text","title":"Under the hood","text":"","category":"section"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"If you're reading here you're curious about what exactly is happening under the hood. So let's get started. Term.jl, like rich in python, defines a simple markup language to specify the style of bits of strings. As we saw, the syntax is very simple with an opening and closing tag specifying the style and marking the start and end of the styled text. ","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"So the first thing that needs to happen is the detection of these markup tags. This is surprisingly hard because there are so many possible combinations. You can have markup tags whose style information varies considerably, you can have nested tags, you can have tags spread across lines and you can have nested tags spread across lines:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"using Term # hide\ntprint(\n    \"\"\"\nAnd [blue] somehow\nit [bold red] all [/bold red]\nhas to [green underline] always\nwork [/green underline] correctly [/blue]\nsomehow.\n    \"\"\"\n)","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"CurrentModule = Term.markup","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"All of this is taken care of by Term.markup.extract_markup which returns a vector of Term.markup.MarkupTag objects. Each of these stores the opening and close tags (as SingleTag objects), the text inbetween them as well as a reference to all MarkupTags nested in it.","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"Normally, you should never use extract_markup directly. Instead you can let Term.style.apply_style handle it. When passed a String, apply_style will use extract_markup to extract style information before applying it to the string. This is done one MarkupTag at the time and recursively (i.e., dealing with nested tags before moving on to the next) until no markup information is found. ","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"After extracting style information, apply_style replaces the MarkupTag information with the appropriate ANSI escape codes. This is done by parsing the markup information (the text bewteen [...]) into a Term.style.MarkupStyle object which stores the style information. Finally, get_style_codes get the ANSI codes corresponding to the required style.  So in summary:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"apply_style(\"[red]text[/red]\")","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"will return a string with style information","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"import Term.style: apply_style  # hide\napply_style(\"[red]text[/red]\") # hide","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"which printed to the console looks like:","category":"page"},{"location":"basics/styled_text/","page":"Styled text","title":"Styled text","text":"import Term.style: apply_style  # hide\nprint(apply_style(\"[red]text[/red]\")) # hide","category":"page"},{"location":"api/api_layout/#Layout","page":"Layout","title":"Layout","text":"","category":"section"},{"location":"api/api_layout/","page":"Layout","title":"Layout","text":"CurrentModule = Term.layout","category":"page"},{"location":"api/api_layout/","page":"Layout","title":"Layout","text":"Pages   = [\"api_layout.md\"]","category":"page"},{"location":"api/api_layout/","page":"Layout","title":"Layout","text":"Modules = [layout]","category":"page"},{"location":"api/api_layout/#Term.layout.Padding","page":"Layout","title":"Term.layout.Padding","text":"Padding\n\nStores information about ammount of padding.\n\n\n\n\n\n","category":"type"},{"location":"api/api_layout/#Term.layout.Spacer","page":"Layout","title":"Term.layout.Spacer","text":"    Spacer\n\nA box of empty text with given width and height.\n\n\n\n\n\n","category":"type"},{"location":"api/api_layout/#Term.layout.hLine","page":"Layout","title":"Term.layout.hLine","text":"hLine\n\nA 1-line renderable made of repeated character from a Box.\n\n\n\n\n\n","category":"type"},{"location":"api/api_layout/#Term.layout.hLine-Tuple{AbstractString}","page":"Layout","title":"Term.layout.hLine","text":"hLine(text::AbstractString; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nConstruct an hLine as wide as the stdout with centered text.\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.hLine-Tuple{Int64}","page":"Layout","title":"Term.layout.hLine","text":"hLine(width::Number, style::Union{String, Nothing}; box::Symbol=:ROUNDED)\n\nCreate a styled hLine of given width.\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.hLine-Tuple{Number, String}","page":"Layout","title":"Term.layout.hLine","text":"hLine(width::Number, text::String; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nCreates an hLine object with texte centered horizontally.\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.hLine-Tuple{Term.renderables.AbstractRenderable}","page":"Layout","title":"Term.layout.hLine","text":"hLine(ren::AbstractRenderable; kwargs)\n\nConstruct an hLine with same width as a renderable\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.hLine-Tuple{}","page":"Layout","title":"Term.layout.hLine","text":"hLine(; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nConstruct an hLine as wide as the stdout\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.vLine","page":"Layout","title":"Term.layout.vLine","text":"vLine\n\nA multi-line renderable with each line made of a | to create a vertical line\n\n\n\n\n\n","category":"type"},{"location":"api/api_layout/#Term.layout.vLine-Tuple{Int64}","page":"Layout","title":"Term.layout.vLine","text":"vLine(height::Number, style::Union{String, Nothing}; box::Symbol=:ROUNDED)\n\nCreate a vLine given a height and, optionally, style information.\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.vLine-Tuple{Term.renderables.AbstractRenderable}","page":"Layout","title":"Term.layout.vLine","text":"vLine(ren::AbstractRenderable; kwargs...)\n\nConstruct a vLine with the same height as a renderable\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.vLine-Tuple{}","page":"Layout","title":"Term.layout.vLine","text":"vLine(; style::Union{String, Nothing}=nothing, box::Symbol=:ROUNDED)\n\nCreate a vLine as tall as the stdout console\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.hstack-Tuple","page":"Layout","title":"Term.layout.hstack","text":"hstack(renderables...)\n\nHorizonatlly stack a variable number of renderables\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.hstack-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}, Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Layout","title":"Term.layout.hstack","text":"hstack(r1::RenderablesUnion, r2::RenderablesUnion)\n\nHorizontally stack two renderables to give a new renderable.\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.pad","page":"Layout","title":"Term.layout.pad","text":"pad(text::AbstractString, left::Int=0, right::Int=0)::String\n\nPad a string by a fixed ammount.\n\n\n\n\n\n","category":"function"},{"location":"api/api_layout/#Term.layout.pad-Tuple{Any, Int64, Symbol}","page":"Layout","title":"Term.layout.pad","text":"pad(text::AbstractString, target_width::Int, method::Symbol)::String\n\nPad a string to width: target_width by adding empty spaces strings \" \". Where the spaces are added depends on the justification method ∈ (:left, :center, :right).\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.vstack-Tuple","page":"Layout","title":"Term.layout.vstack","text":"vstack(renderables...)\n\nVertically stack a variable number of renderables\n\n\n\n\n\n","category":"method"},{"location":"api/api_layout/#Term.layout.vstack-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}, Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Layout","title":"Term.layout.vstack","text":"vstack(r1::RenderablesUnion, r2::RenderablesUnion)\n\nVertically stack two renderables to give a new renderable.\n\n\n\n\n\n","category":"method"},{"location":"ren/intro/#RenIntro","page":"Renderables","title":"Renderables","text":"","category":"section"},{"location":"ren/intro/","page":"Renderables","title":"Renderables","text":"These next few page dive deeper into each specific type of renderable, enjoy!","category":"page"},{"location":"ren/layout_rens/#Layout-renderables","page":"Layout renderables","title":"Layout renderables","text":"","category":"section"},{"location":"ren/layout_rens/","page":"Layout renderables","title":"Layout renderables","text":"We've already seen the layout elements in detail, but we'll just remind you of them here. There's three types of renderabels whick mainly aime with getting the right layout for your renderables: Spacer, vLine and hLine.  ","category":"page"},{"location":"ren/layout_rens/","page":"Layout renderables","title":"Layout renderables","text":"Spacer creates a box of empty text with a given width and height. This can be useful for instance if you're stacking two other renderables but want some space between them:","category":"page"},{"location":"ren/layout_rens/","page":"Layout renderables","title":"Layout renderables","text":"import Term: Panel, Spacer\n\n\np = Panel(; width=10, height=3)\nspace = Spacer(5, 3)\nprint(p * space * p)\nprint(p * p)","category":"page"},{"location":"ren/layout_rens/","page":"Layout renderables","title":"Layout renderables","text":"vLine and hLine are more useful to create a separation between two separate peices of content:","category":"page"},{"location":"ren/layout_rens/","page":"Layout renderables","title":"Layout renderables","text":"\nimport Term: TextBox, vLine, hLine\n\n\nmy_long_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut...\"\n\ntb = TextBox(my_long_text; width=22)\nline = \" \" /vLine(tb.measure.h-2; style=\"dim bold\")\n\ntop = tb * line * tb\n\ntb2 = TextBox(my_long_text; width=top.measure.w)\nhline = hLine(top.measure.w; style=\"dim\", box=:DOUBLE)\n\nprint(top / hline / tb2)","category":"page"},{"location":"ren/tbox/#TBoxDoc","page":"TextBox","title":"TextBox","text":"","category":"section"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"TextBoxes are a very simple but very useful renderable. They bring together the functionality of RenderableText with that of Panel. In fact you can think of  just a panel with a some text inside and with its box hidden.  Why do we need them, you say? Well because now you can have a piece of text, with a nice title and sub title.","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"import Term: TextBox\n\nprint(\n    TextBox(\n        \",\"^100 * \"\\n\",\n        title=\"title!\",\n        subtitle=\"sub title!\",\n        width=30,\n        title_style=\"bold red\",\n        subtitle_style=\"dim\",\n        title_justify=:center,\n    )\n)","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"Okay, admittedly that's not huge. But it still nice to have. It also helps with keeping layout consistent when mixing panels and text, have a look:","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"import Term: RenderableText, Panel\n\nt = \",\"^100\n\ntext = RenderableText(t; width=22)\npanel = Panel(t, width=22)\n\n\nprint(\n    text, panel\n)","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"you see? The panel and the text have the same width, BUT, the panel must fit its box, some padding and its content within the same width. So the size of the text inside will need to change compared to RenderableText(t; width=22). If we use a TextBox on the other hand:","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"\ntbox = TextBox(t, width=22)\npanel = Panel(t, width=22)\n\nprint(\n    tbox, panel\n)","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"Now the two pieces of text look the same and the final layout is a lot more homogeneous, success!","category":"page"},{"location":"ren/tbox/#Fitting-and-truncating","page":"TextBox","title":"Fitting and truncating","text":"","category":"section"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"Like for panel, we have a few options on how we want the length of the text and the size of the textbox to look like. The simplest thing is specifying the width of the textbox, the text will be reshaped to fit in:","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"import Term: TextBox \ntext = \"x\"^500\n\nprint(TextBox(text))\nprint(TextBox(text; width=44))","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"But we can also fit the box to the text. In that case the box will be as large as it needs to be (still fitting within your terminal window):","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"print(TextBox(text; fit=:fit))","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"and finally, we can truncate the text so that it's as wide at the box,  discarding what's left:","category":"page"},{"location":"ren/tbox/","page":"TextBox","title":"TextBox","text":"\nprint(TextBox(text; fit=:truncate))","category":"page"},{"location":"adv/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"Julia has a great logging system. If you come from other programming languages like Python you'll likely already love it, but it can be better!","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"AS you know, if you use logging macros like @info with a bunch of arguments after, Julia produces something like this:","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"@info \"My log message\" 1+1 n=\"a string!\" :x","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"It shows your log messages and then the other arguments as key = value display even evaluating expressions like 1 + 1 and showing you the result. Very useful, but visually a bit dull. Also, we might want additional info to be shown: at what time was the log message produced, by which line of code, inside which function, what are the types of the arguments...","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"Well, Term provides logging functionality that gives all that information, plus a ton of styling on top. To do that we need to install Term's own logger (TermLogger, very creative name) as the global logger to handle all error messages:","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"import Term: install_term_logger\ninstall_term_logger()","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"Done. Not a lot of work. Now you can just use your logging macros as you would normally, you don't need to change anything. But magic will happen:","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"import Term: TermLogger, theme; import Logging: with_logger # hide\nwith_logger(TermLogger(stderr, theme)) do # hide\n\n@info \"My log message\" 1+1 n=\"a string!\" :x\n\nend # hide","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"As you can see, it shows all the information that is normally there, an more!  If your log macro is called from within a function, it will also tell you that:","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"with_logger(TermLogger(stderr, theme)) do # hide\n\nfunction my_useful_function()\n    @info \"My log message\" 1+1 n=\"a string!\" :x\nend\n\nmy_useful_function()\n\nend # hide","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"And of course it works nicely with all logging macros:","category":"page"},{"location":"adv/logging/","page":"Logging","title":"Logging","text":"with_logger(TermLogger(stderr, theme)) do # hide\n\n@info \"just some info\"\n@warn \"careful!\"\n@error \"uh oh, not good!\"\n\nend # hide","category":"page"},{"location":"adv/errors_tracebacks/#Errors","page":"Errors","title":"Errors","text":"","category":"section"},{"location":"adv/errors_tracebacks/","page":"Errors","title":"Errors","text":"In Logging we've seen how Term can replace the default logging system in Julia to produce stylized logging messages. Term can do the same for error messages and stack traces.","category":"page"},{"location":"adv/errors_tracebacks/","page":"Errors","title":"Errors","text":"danger: Danger zone\nThe way the error functionality is currently handled in Term entails re-defining methods from Base, Julia's own code. This is undesirable. It works, but it may lead to problems for some users or some unexpected behaviors, especially if other functions expected the re-defined code to work differently from how it works in Term. While this is fine if you're just writing code for your own comsumption, we strongly discourage using Term's error functionality in production level code - code that needs to be turned into something that many people will use. We can't guarantee that this wouldn't results in a bunch of headaches.  With this warning in place, we do hope that in the future Julia will provide hooks for error handling systems as it does for logging. In the meanwhile, you can enjoy Term's stack traces privately in your code.","category":"page"},{"location":"adv/errors_tracebacks/","page":"Errors","title":"Errors","text":"Setting up Term to handle errors for you is very simple:","category":"page"},{"location":"adv/errors_tracebacks/","page":"Errors","title":"Errors","text":"import Term: install_stacktrace\n\ninstall_stacktrace()  # entering the danger zone\n\n1 + \"this wont work\"","category":"page"},{"location":"adv/errors_tracebacks/","page":"Errors","title":"Errors","text":"(Image: )","category":"page"},{"location":"api/api_panel/#Panel","page":"Panel","title":"Panel","text":"","category":"section"},{"location":"api/api_panel/","page":"Panel","title":"Panel","text":"CurrentModule = Term.panel","category":"page"},{"location":"api/api_panel/","page":"Panel","title":"Panel","text":"Pages   = [\"api_panel.md\"]","category":"page"},{"location":"api/api_panel/","page":"Panel","title":"Panel","text":"Modules = [panel]","category":"page"},{"location":"api/api_panel/#Term.panel.Panel","page":"Panel","title":"Term.panel.Panel","text":"Panel\n\nRenderable with a panel surrounding some content:         ╭──────────╮         │ my panel │         ╰──────────╯\n\n\n\n\n\n","category":"type"},{"location":"api/api_panel/#Term.panel.Panel-Tuple{Union{AbstractString, Term.renderables.AbstractRenderable}}","page":"Panel","title":"Term.panel.Panel","text":"Panel(\n    content::AbstractRenderable;\n    width::Int = 88,\n    height::Union{Nothing,Int} = nothing,\n    fit::Bool=false,\n    padding::Union{Padding, NTuple} = Padding(2, 2, 0, 0),\n    kwargs...\n)\n\nConstruct a Panel around of a AbstractRenderable\n\n\n\n\n\n","category":"method"},{"location":"api/api_panel/#Term.panel.Panel-Tuple{Vector{Union{AbstractString, Term.renderables.AbstractRenderable}}}","page":"Panel","title":"Term.panel.Panel","text":"Panel(renderables; kwargs...)\n\nPanel constructor for creating a panel out of multiple renderables at once.\n\n\n\n\n\n","category":"method"},{"location":"api/api_panel/#Term.panel.Panel-Tuple{}","page":"Panel","title":"Term.panel.Panel","text":"Panel(; \n    fit::Symbol=:nofit,\n    width::Int = 88,\n    height::Union{Nothing,Int} = nothing, \n    kwargs...\n)\n\nConstruct a Panel with no content\n\n\n\n\n\n","category":"method"},{"location":"api/api_panel/#Term.panel.TextBox","page":"Panel","title":"Term.panel.TextBox","text":"TextBox\n\nCreates a Panel and fits input text to it. The pannel is hidden so that the result is just a text box.\n\n\n\n\n\n","category":"type"},{"location":"api/api_panel/#Term.panel.TextBox-Tuple{AbstractString}","page":"Panel","title":"Term.panel.TextBox","text":"TextBox(\n    text::Union{Vector, AbstractString};\n    width::Union{Nothing, Int}=nothing,\n    title::Union{Nothing, String}=nothing,\n    title_style::Union{String, Nothing}=\"default\",\n    title_justify::Symbol=:left,\n    subtitle::Union{String, Nothing}=nothing,\n    subtitle_style::Union{String, Nothing}=\"default\",\n    subtitle_justify::Symbol=:left,\n    justify::Symbol=:left,\n    fit::Symbol=:fit,\n    )\n\nCreates an hidden Panel with text in it.\n\nIf a width is passed, the input text is reshaped to have that size, unless fit=:truncate in which case it's cut to size. If no width is passed and fit=true the TextBox's size matches the size of the input text. Other arguments behave like Panel.\n\nSee also Panel.\n\n\n\n\n\n","category":"method"},{"location":"api/api_panel/#Term.panel.render_panel-Tuple{Any}","page":"Panel","title":"Term.panel.render_panel","text":"Panel(\n        style::String,\n        title_style::String,\n        title_justify::Symbol,\n        subtitle::String,\n        subtitle_style::String,\n        subtitle_justify::String,\n        panel_measure::Measure,\n        content_measure::Measure,\n        Δw::Int,\n        Δh::Int,\n        padding::Padding\n    )\n\nConstruct a Panel given all required info.\n\n\n\n\n\n","category":"method"},{"location":"api/api_renderables/#Renderables","page":"Renderables","title":"Renderables","text":"","category":"section"},{"location":"api/api_renderables/","page":"Renderables","title":"Renderables","text":"CurrentModule = Term.renderables","category":"page"},{"location":"api/api_renderables/","page":"Renderables","title":"Renderables","text":"Pages   = [\"api_renderables.md\"]","category":"page"},{"location":"api/api_renderables/","page":"Renderables","title":"Renderables","text":"Modules = [renderables]","category":"page"},{"location":"api/api_renderables/#Term.renderables.AbstractRenderable","page":"Renderables","title":"Term.renderables.AbstractRenderable","text":"AbstractRenderable\n\n\n\n\n\n","category":"type"},{"location":"api/api_renderables/#Term.renderables.Renderable-Tuple{AbstractString}","page":"Renderables","title":"Term.renderables.Renderable","text":"Renderable(\n    str::String; width::Union{Nothing,Int} = nothing\n)\n\nConvenience method to construct a RenderableText\n\n\n\n\n\n","category":"method"},{"location":"api/api_renderables/#Term.renderables.RenderableText-Tuple{AbstractString}","page":"Renderables","title":"Term.renderables.RenderableText","text":"RenderableText(text::String; width::Union{Nothing, Int, Symbol}=nothing)\n\nConstruct a RenderableText out of a string.\n\nIf a width is passed the text is resized to match the width.\n\n\n\n\n\n","category":"method"},{"location":"api/api_renderables/#Term.renderables.RenderableText-Tuple{RenderableText}","page":"Renderables","title":"Term.renderables.RenderableText","text":"RenderableText(rt::RenderableText; width::Union{Nothing,Int} = nothing)\n\nConstruct a RenderableText by possibly re-shaping a RenderableText\n\n\n\n\n\n","category":"method"},{"location":"api/api_renderables/#Term.renderables.RenderableText-Tuple{Vector}","page":"Renderables","title":"Term.renderables.RenderableText","text":"RenderableText(text::Vector; width::Union{Nothing,Int} = nothing)\n\nConstruct a RenderableText out a vector of objects.\n\n\n\n\n\n","category":"method"},{"location":"api/api_renderables/#Base.string-Tuple{Term.renderables.AbstractRenderable}","page":"Renderables","title":"Base.string","text":"Base.string(r::AbstractRenderable)::String\n\nCreates a string representation of a renderable\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Tree","page":"Tree","title":"Tree","text":"","category":"section"},{"location":"api/api_tree/","page":"Tree","title":"Tree","text":"CurrentModule = Term.tree","category":"page"},{"location":"api/api_tree/","page":"Tree","title":"Tree","text":"Pages   = [\"api_tree.md\"]","category":"page"},{"location":"api/api_tree/","page":"Tree","title":"Tree","text":"Modules = [tree]","category":"page"},{"location":"api/api_tree/#Term.tree.Leaf","page":"Tree","title":"Term.tree.Leaf","text":"Leaf\n\nEnd items in a Tree. No sub-trees.\n\n\n\n\n\n","category":"type"},{"location":"api/api_tree/#Term.tree.Tree","page":"Tree","title":"Term.tree.Tree","text":"Tree\n\nA tree is composed of nodes (other trees) and leaves (end items). It renders as a hierarchical structure with lines (guides) connecting the various elements\n\n\n\n\n\n","category":"type"},{"location":"api/api_tree/#Term.tree.Tree-Tuple{DataType}","page":"Tree","title":"Term.tree.Tree","text":"Tree(T::DataType)::Tree\n\nConstruct a Tree visualization of T's types hierarchy\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Term.tree.Tree-Tuple{Union{Dict, Pair}}","page":"Tree","title":"Term.tree.Tree","text":"Tree(data::Union{Dict, Pair}; level=0, title::String=\"tree\", kwargs...)\n\nConstruct a Tree out of a Dict. Recursively handle nested Dicts.\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Term.tree.TreeGuides","page":"Tree","title":"Term.tree.TreeGuides","text":"TreeGuides\n\nStore strings to make up a Tree's guides (the line elements showing connections).\n\n\n\n\n\n","category":"type"},{"location":"api/api_tree/#Term.tree.TreeGuides-Tuple{Symbol, String}","page":"Tree","title":"Term.tree.TreeGuides","text":"TreeGuides(guides_type::Symbol, style::String)\n\nGet tree guides with style information applied\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Base.show-Tuple{IO, Tree}","page":"Tree","title":"Base.show","text":"Show/render a Tree\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Term.tree.asleaf","page":"Tree","title":"Term.tree.asleaf","text":"asleaf\n\nStyle an object to render it as a a string\n\n\n\n\n\n","category":"function"},{"location":"api/api_tree/#Term.tree.make_hierarchy_dict-Tuple{Tuple{Vararg{T, N}} where {N, T}, DataType, Dict}","page":"Tree","title":"Term.tree.make_hierarchy_dict","text":"make_hierarchy_dict(x::Vector{DataType}, T::DataType, Tsubs::Dict)::Dict\n\nRecursively create a dictionary with the types hierarchy for T. Tsubs carries information about T's subtypes. The Dict is made backwards. From  the deepest levels up.\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Term.tree.render-Tuple{Tree}","page":"Tree","title":"Term.tree.render","text":"render(tree::Tree)::Vector{Segment}\n\nRender a Tree into segments. Recursively handle nested trees.\n\n\n\n\n\n","category":"method"},{"location":"api/api_tree/#Term.tree.style_T-Tuple{Any}","page":"Tree","title":"Term.tree.style_T","text":"Apply style for the type whose hierarchy Tree we are making\n\n\n\n\n\n","category":"method"},{"location":"basics/basics/#Intro","page":"Intro","title":"Intro","text":"","category":"section"},{"location":"basics/basics/","page":"Intro","title":"Intro","text":"This section aims to introduce the basic concepts about Term. It will show how to create styled text with color and style information and how to create more complex renderable objects such as Panel and TextBoxes. Finally we'll go over how to 'stack' these renderables to crate complex layouts in your terminal. ","category":"page"},{"location":"basics/basics/","page":"Intro","title":"Intro","text":"The main goal of all of this is to produce beautiful, informative, terminal outputs.  Term can do a lot more than this (e.g., it can replace the standard logging system in Julia), but this kind of advanced functionality is discussed in a separate section.","category":"page"},{"location":"basics/basics/","page":"Intro","title":"Intro","text":"Let's get started!","category":"page"},{"location":"ren/text/#RtextDoc","page":"RenderableText","title":"RenderableText","text":"","category":"section"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"RenderableText, what is it? Exactly what the name says: a renderable that stores a bit of text:","category":"page"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"using Term # hide\nrend = RenderableText(\"\"\"\n[bold red]Woah, my first [yellow italic]`Renderable`!\n\"\"\")\nprint(rend)","category":"page"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"Nothing special here. You'll notice that RenderableText automatically applies style information though. Also, when we were just styling strings before we had to use tprint instead of the normal print function to get our styled output. Well no more! Renderable objects work well with print so you can drop that t (when printed renderables print their Segmens remember? Segments already store style information). ","category":"page"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"Now, do we really need a whole new type just to print a bit of text? Of course not, but RenderableText does more than that!","category":"page"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"import Term: RenderableText\n\nprint(RenderableText(\",\"^100; width=25))\nprint(\"\\n\"^2)\nprint(RenderableText(\",\"^100; width=50))","category":"page"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"magic! When we pass a width argument RenderableText reshapes our input text to the desired width! As you can imagine, when you're creating a layout made up of multiple elements, you want to be able to control the width of each element, so here you go! ","category":"page"},{"location":"ren/text/","page":"RenderableText","title":"RenderableText","text":"Admittedly this is not huge, but it can come in handy sometimes. More importantly, the behavior of RenderableText also give you an idea of what happens to your strings when you put them in a Panel or TextBox renderable, so let's look at them!","category":"page"},{"location":"adv/adv/#Intro","page":"Intro","title":"Intro","text":"","category":"section"},{"location":"adv/adv/","page":"Intro","title":"Intro","text":"In the Basics section we've learned how to style text, create renderables and stack them into more complex layouts. You can use all of that to produce great terminal output for your Julia code, but that doesn't exhaust the range of things Term can do. ","category":"page"},{"location":"adv/adv/","page":"Intro","title":"Intro","text":"In this section we'll have a look at Term's additional functionality: logging discusses how to replace the default logging system in Julia to style logging messages with Term, Errors looks at how to replace the standard error messages with better ones made by Term and introspection will discuss Term's inspect function which can be used to peek into objects in your Julia code.","category":"page"},{"location":"adv/adv/","page":"Intro","title":"Intro","text":"Let's get started.","category":"page"},{"location":"adv/progressbars/#Progress-bars","page":"Progress bars","title":"Progress bars","text":"","category":"section"},{"location":"adv/progressbars/#General-usage","page":"Progress bars","title":"General usage","text":"","category":"section"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"Progress bars! We all love progress bars, and julia has some great progress bars packages.  But this is Term, and Term too has its own progress bars API. We think you'll like it.","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"warning: Warning\nIn the docs each \"update\" of the progress bar gets printed in a new line. This is not what it looks like in reality. We encourage you to copy-paste the code below and try it out in your own console. Or head to github where you can find more examples.","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"So this is what a progress bar looks like in Term:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: track\n\nmyvec = collect(1:5)\nfor i in track(myvec; width=60)\n    # do stuff\n    sleep(.025)\nend","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"You'll noticed that we used a function track for the whole thing. track accepts an iterable object (e.g., a vector, or a range) in the context of a for loop. It then takes care of creating, starting, and stopping your very own ProgressBar object. It also takes a bunch of arguments to specify how exactly the progress bar should appear, more on that below.","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"Now, track is handy because it takes care of most of the work. But lets look in more detail at what goes on under the hood (which can be useful when you want more control over your bars). A progress bar is represented by the creatively named ProgressBar type. When initializing a new instance of it you must say how many iterations will the bar have to run over:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: ProgressBar\npbar = ProgressBar(100)","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"When you want to sue your progress bar you need to start it, update it and stop it. Everytime you update pbar it adds a +1 to its internal counter of how many iterations it's done (until it's done all the iterations you've set out at the beginning), You can reset this by specifying the iteration number: update(pbar, 50). So this is what it looks like:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: track, ProgressBar, update, start, stop\n\n# create progress bar\npbar = ProgressBar(;N=5, description=\"Manual pbar\", width=60)\n\n# loop da loop\nfor i in 1:5\n    # do stuff\n    sleep(.01)\n\n    # manually update the progress bar\n    update(pbar)\nend\nstop(pbar)","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"You'll see that we've passed description to specify the text that goes before the bar in the progress bar. There's other arguments you can use to set the bar's appearance:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: track\nimport Term.color: RGBColor\n\ntrk(x) = track(x;\n    description=\"[red bold]Choose your colors![/red bold]\",\n    expand=true,  #  fill the screen\n    update_every=5,  # don't update at every iteration\n    columns=:detailed,  # print more info\n    colors = [\n        RGBColor(\"(.3, .3, 1)\"),\n        RGBColor(\"(1, 1, 1)\"),\n        RGBColor(\"(.9, .3, .3)\"),\n    ]\n)\n\nprint(\"\\n\")\nfor i in trk(1:10)\n    sleep(0.005)\nend","category":"page"},{"location":"adv/progressbars/#Columns","page":"Progress bars","title":"Columns","text":"","category":"section"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"What's going on with columns=:detailed you ask? Well let me tell you. Each bit of information in the progress bar visualization is a Column. The initial description, those pink dots, the progress bar itself... all columns. There's many types of columns and you can create your own. You can mix and match different columns to create your own progress bar visualization. Term provides three presets to visualize increasing amounts of information with your progress bar:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: track\n\n\nfor (level, color) in zip((:minimal, :default, :detailed), (\"red\", \"green\",\"blue\"))\n    for i in track(1:5; description=\"[bold $color italic]$level[/bold $color italic]\", columns=level, width=150)\n        sleep(.005)\n    end\nend\n","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"As you can see, regardless of how many columns there are the progress bar will have the right width. That's because each column is a Term renderable object and as such has a Measure object that tells us about it's width. The size of the bar in the progress bar is then adjusted to fit in all the columns. ","category":"page"},{"location":"adv/progressbars/#Custom-columns","page":"Progress bars","title":"Custom columns","text":"","category":"section"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"Nice right? Let's see how to make your own column with a simple exampe: a column that just shows the current iteration number.","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"All columns are subtypes of an AbstractColumn <: AbstractRenderable type, so they must have a segments and a measure field. You can create a column like this:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: AbstractColumn, DescriptionColumn, BarColumn\nimport Term.style: apply_style  # to style strings\nimport Term.measure: Measure  # to define the column's size\n\n# define a new column type\nstruct MyCol <: AbstractColumn\n    segments::Vector\n    measure::Measure\n    style::String\nend\n\n# constructor\nMyCol(style::String) = MyCol([], Measure(10, 1), style)","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"The only other thing you need to define is a function that updates the columns display","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"# define a function to update the column when the progress bar is updated\n# it must return a string\nTerm.progress.update(col::MyCol, i::Int, args...)::String = return apply_style(\"[$(col.style)]$i[/$(col.style)]\")","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"That should do it. Now we can specify our own set fo columns before creating the visualization:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"cols = [\n    DescriptionColumn(\"MY columns!!!\"),\n    BarColumn(),  # this will show the actual bar\n    MyCol(\"bold red\"),\n]\n\nline()\nfor i in track(1:100; columns=cols)\n    sleep(.01)\nend","category":"page"},{"location":"adv/progressbars/#Transient-bars","page":"Progress bars","title":"Transient bars","text":"","category":"section"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"Sometimes you need loads of progress bars. Why? Not sure, but lets say you do. You likely don't want your terminal to be cluttered by loads of finished progress bars, right? Well lucky you! You can make ProgressBar transient so that it just disappears when it's done:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"\nimport Term: tprint\nimport Term.progress: track\n\nfor i in 1:3\n    for j in track(1:5; description=\"[yellow bold]Transient pbars![/yellow bold]\", transient=true)\n        sleep(0.001)\n\n    end\nend\ntprint(\"[bright_blue bold]poof![/bright_blue bold] [underline bright_blue]They disappeared[/]\")","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"note: Note\nOkay, they didn't really disappear. But they will in the terminal, promised.","category":"page"},{"location":"adv/progressbars/#A-note-on-STDOUT","page":"Progress bars","title":"A note on STDOUT","text":"","category":"section"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"This is more advanced than most people will care about, but if you're confused about why the stuff you print in your for loops is not showing up perhaps have a look.","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"The way the progress bar happens, in practice, is that ANSI codes are used to move the cursor around in the terminal and erase the old progress bar before the update version is printed. This means that if you tried to print suff to terminal during the progress bar updates everything would go wrong! We woulnd't know which line to erase, where to print! A mess. So, what we do is we redirect your STDOUT for the duration of the progress bar and only show it to you once the progress bar is done. That's why you need to wait until the end of the loop to see the results of print:","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"import Term.progress: track\n\nfor i in track(1:5)\n    print(\"where is my text!\")\nend","category":"page"},{"location":"adv/progressbars/","page":"Progress bars","title":"Progress bars","text":"You can disable this behavior by passing redirectstdout=false to track and ProgressBar.","category":"page"},{"location":"api/api_style/#Style","page":"Style","title":"Style","text":"","category":"section"},{"location":"api/api_style/","page":"Style","title":"Style","text":"CurrentModule = Term.style","category":"page"},{"location":"api/api_style/","page":"Style","title":"Style","text":"Pages   = [\"api_style.md\"]","category":"page"},{"location":"api/api_style/","page":"Style","title":"Style","text":"Modules = [style]","category":"page"},{"location":"api/api_style/#Term.style.MarkupStyle","page":"Style","title":"Term.style.MarkupStyle","text":"MarkupStyle\n\nHolds information about the style specification set out by a MarkupTag.\n\n\n\n\n\n","category":"type"},{"location":"api/api_style/#Term.style.MarkupStyle-Tuple{Any}","page":"Style","title":"Term.style.MarkupStyle","text":"MarkupStyle(tag::MarkupTag)\n\nBuilds a MarkupStyle definition from a MarkupTag.\n\n\n\n\n\n","category":"method"},{"location":"api/api_style/#Term.style.apply_style-Tuple{Any}","page":"Style","title":"Term.style.apply_style","text":"apply_style(text)\n\nApply style to a piece of text.\n\nExtract markup style information and insert the  appropriate ANSI codes to style a string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_style/#Term.style.get_style_codes-Tuple{Term.style.MarkupStyle}","page":"Style","title":"Term.style.get_style_codes","text":"get_style_codes(style::MarkupStyle)\n\nGet ANSICodes corresponding to a MarkupStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/api_style/#Term.style.is_mode-Tuple{Any}","page":"Style","title":"Term.style.is_mode","text":"Check if a string is a mode name\n\n\n\n\n\n","category":"method"},{"location":"api/api_progressbars/#ProgressBars","page":"ProgressBars","title":"ProgressBars","text":"","category":"section"},{"location":"api/api_progressbars/","page":"ProgressBars","title":"ProgressBars","text":"CurrentModule = Term.progress","category":"page"},{"location":"api/api_progressbars/","page":"ProgressBars","title":"ProgressBars","text":"Pages   = [\"api_progress.md\"]","category":"page"},{"location":"api/api_progressbars/","page":"ProgressBars","title":"ProgressBars","text":"Modules = [progress]","category":"page"},{"location":"api/api_progressbars/#Term.progress.ProgressBar","page":"ProgressBars","title":"Term.progress.ProgressBar","text":"ProgressBar\n\nProgress bar Type, stores information required to render a progress bar renderable.\n\n\n\n\n\n","category":"type"},{"location":"api/api_progressbars/#Term.progress.TempSTDOUT","page":"ProgressBars","title":"Term.progress.TempSTDOUT","text":"TempSTDOUT\n\nStores information about a temporarily re-directed STDOUT\n\n\n\n\n\n","category":"type"},{"location":"api/api_progressbars/#Term.progress.Track","page":"ProgressBars","title":"Term.progress.Track","text":"Track\n\nConvenience iterator to add a ProgressBar to for loops.\n\nfor i in track(1:100)\n    # ... do something\nend\n\nAdds a progress bar that updates for each iteration through the loop.\n\n\n\n\n\n","category":"type"},{"location":"api/api_progressbars/#Base.iterate-Tuple{Term.progress.Track, Any}","page":"ProgressBars","title":"Base.iterate","text":"Update progress bar and continue iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/api_progressbars/#Base.iterate-Tuple{Term.progress.Track}","page":"ProgressBars","title":"Base.iterate","text":"Start iteration. Crate Progress Bar\n\n\n\n\n\n","category":"method"},{"location":"api/api_progressbars/#Term.progress.pbar_color-Tuple{Term.progress.ProgressBar}","page":"ProgressBars","title":"Term.progress.pbar_color","text":"pbar_color(pbar::ProgressBar)\n\nGet the RGB color of of a progress bar's bar based on progress.\n\n\n\n\n\n","category":"method"},{"location":"api/api_progressbars/#Term.progress.track-Tuple{Any}","page":"ProgressBars","title":"Term.progress.track","text":"Costructor for a Track object.\n\n\n\n\n\n","category":"method"},{"location":"api/api_progressbars/#Term.progress.update-Tuple{Term.progress.ProgressBar}","page":"ProgressBars","title":"Term.progress.update","text":"update(pbar::ProgressBar)\n\nUpdate progress bar info and display.\n\n\n\n\n\n","category":"method"},{"location":"basics/colors/#Colors","page":"Colors","title":"Colors","text":"","category":"section"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"Okay, so far so good. We can use macros like @red and the tprint function to print colored strings. But so far we've only been using few named colors, but..","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"function rainbow_maker() # hide\n    text = \"there's a whole rainbow\\n of colors out there\" # hide\n    _n = Int(length(text)/2)  # hide\n    R = hcat(range(30, 255, length=_n), range(255, 60, length=_n))  # hide\n    G =hcat(range(255, 60, length=_n), range(60, 120, length=_n))  # hide\n    B = range(50, 255, length=length(text))  # hide\n    out = \"\"  # hide\n    for n in 1:length(text)  # hide\n        r, g, b = R[n], G[n], B[n]  # hide\n        out *= \"[($r, $g, $b)]$(text[n])[/($r, $g, $b)]\"  # hide\n    end # hide\n    return out  # hide\nend # hide\nimport Term: tprint  # hide\ntprint(rainbow_maker()) # hide","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"so how can we use different kinds of colors? It's all done through Term's markup syntax of course. Look:","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"using Term: tprint # hide\ntprint(\"[(255, 50, 100)]colors![/(255, 50, 100)]\")","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"yep, you can pass a set of (r, g, b) values and that'll do it. Personally, I prefer working with hex codes, and so Term can accept them too:","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"using Term: tprint # hide\nindigo = \"#42A5F5\"\n\ntprint(\"Some [$indigo]color![/$indigo]\")","category":"page"},{"location":"basics/colors/#Under-the-hood","page":"Colors","title":"Under the hood","text":"","category":"section"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"What Term is doing here is taking each bit of style information in the markup tag (each word or each (...) within [...]) and constructing style codes with an ANSICode object.","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"If the style informaton represents a color, Term first represents it as a AbstractColor type: NamedColor or BitColor or RGBColor.  ","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"NamedColor objects represent simple colors like red and blue, BitColor represent 16-bit colors like dark_goldenrod and RGBColor, surprisingly, represents rgb-style colors. There's no method to represent hex colors as these are converted into rgb first. ","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"The distinction between NamedColor, BitColor and RGBColor is necessary because the three color styles are represented by a different syntax in the ANSI codes. Naturally, Term users won't normally worry about this and can use whichever color formulation is most convenient.","category":"page"},{"location":"basics/colors/#Colors-2","page":"Colors","title":"Colors","text":"","category":"section"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"Below all named colors, 16bit colors and (many) RGB colors are printed for display.","category":"page"},{"location":"basics/colors/","page":"Colors","title":"Colors","text":"import Term: CODES_16BIT_COLORS\nimport Term: Panel\n\nfunction make_named_colors()\n    sort_idx = sortperm(collect(values(CODES_16BIT_COLORS)))\n    cnames = collect(keys(CODES_16BIT_COLORS))[sort_idx][1:9]\n    colors = \"\"\n    colors = join(map(\n        (c)->\"[on_$c] [/on_$c]\", cnames\n    ))\n    return colors\nend\n\nfunction make_16bit_colors()\n    sort_idx = sortperm(collect(values(CODES_16BIT_COLORS)))\n    cnames = collect(keys(CODES_16BIT_COLORS))[sort_idx][9:end]\n    colors = \"\"\n    colors = join(map(\n        (c)->\"[on_$c] [/on_$c]\", cnames\n    ))\n    return colors\nend\n\nfunction make_rgb_colors()\n    values = 1:25:255\n    colors = \"\"\n    for r in values, b in values, g in values[1:end-1]\n        colors *= \"[on_($r, $g, $b)] [/on_($r, $g, $b)]\"\n    end\n    return colors\nend\n\n\n\nprint(\n    Panel(make_named_colors(), width=20, justify=:center, title=\"Named  colors\", style=\"bold yellow\") / # stacking operator, see layout page\n    Panel(make_16bit_colors(), width=42, title=\"16 bit colors\", style=\"bold yellow\") / \n    Panel(make_rgb_colors(), width=88, title=\"RGB colors\", style=\"bold yellow\")\n)","category":"page"},{"location":"api/api_console/#Console","page":"Console","title":"Console","text":"","category":"section"},{"location":"api/api_console/","page":"Console","title":"Console","text":"CurrentModule = Term.consoles","category":"page"},{"location":"api/api_console/","page":"Console","title":"Console","text":"Pages   = [\"api_console.md\"]","category":"page"},{"location":"api/api_console/","page":"Console","title":"Console","text":"Modules = [consoles]","category":"page"},{"location":"api/api_console/#Term.consoles.Console","page":"Console","title":"Term.consoles.Console","text":"Console\n\nThe Console object stores information about the dimensions of the output(::IO) where objects will be printed\n\n\n\n\n\n","category":"type"},{"location":"api/api_console/#Term.consoles.beginning_previous_line-Tuple{}","page":"Console","title":"Term.consoles.beginning_previous_line","text":"Move cursor to the beginning of the previous line\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.clear-Tuple{}","page":"Console","title":"Term.consoles.clear","text":"Clear terminal.\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.console_height-Tuple{}","page":"Console","title":"Term.consoles.console_height","text":"console_height()\n\nGet the current console height.\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.console_width-Tuple{}","page":"Console","title":"Term.consoles.console_width","text":"console_width()\n\nGet the current console width.\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.cursor_position-Tuple{}","page":"Console","title":"Term.consoles.cursor_position","text":"Get cursor position\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.down-Tuple{}","page":"Console","title":"Term.consoles.down","text":"Move cursor down one line\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.erase_line-Tuple{}","page":"Console","title":"Term.consoles.erase_line","text":"Erase last line in console.\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.hide_cursor-Tuple{}","page":"Console","title":"Term.consoles.hide_cursor","text":"Hide cursor\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.line-Tuple{}","page":"Console","title":"Term.consoles.line","text":"Print a new line.\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.show_cursor-Tuple{}","page":"Console","title":"Term.consoles.show_cursor","text":"Show cursor\n\n\n\n\n\n","category":"method"},{"location":"api/api_console/#Term.consoles.up-Tuple{}","page":"Console","title":"Term.consoles.up","text":"Move cursor up one line\n\n\n\n\n\n","category":"method"},{"location":"basics/content_layout/#content_layout","page":"Content layout","title":"Content layout","text":"","category":"section"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"Okay, so we can style text and we can create fancy panels. Cool. Not enough. If we want to get real fancy we need to combine multiple renderable elements. Like this:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term\nprint(Term.make_logo())","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"The example above is composed of panels and textboxes, of course, but also additional lines and spacing elements that can help with the layout. These elements are combined using a very simple syntax to create the whole thing.","category":"page"},{"location":"basics/content_layout/#Nesting","page":"Content layout","title":"Nesting","text":"","category":"section"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"The easiest way to create a layout is to nest things. We've already briefly seen how to do this with Panels:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"\nimport Term: Panel # hide\n\nprint(\n    Panel(\n        Panel(\n            Panel(\n                \"We need to go deeper...\",\n                height=3,\n                width=28,\n                style=\"green\",\n                box=:ASCII,\n                title=\"ED\",title_style=\"white\",\n                justify=:center\n            ),\n            style=\"red\", box=:HEAVY, title=\"ST\", title_style=\"white\", fit=true\n        ),\n        width=44, justify=:center, style=\"blue\", box=:DOUBLE, title=\"NE\", title_style=\"white\"\n    )\n)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"That's all there is really. Panel can take one or multiple string and AbstractRenderable objects as argument and stacks them inside. You can combine this with the width, height and justify argument to mix things up, but simple nesting will only take you so far. We need better way to compose a layout.","category":"page"},{"location":"basics/content_layout/#Stacking","page":"Content layout","title":"Stacking","text":"","category":"section"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"The idea is simple: horizontally stack two renderables and they will appear side by side, stack them vertically and they will appear one over the other. The syntax is even simpler: * lets you horizontally stack (or concatenate strings) and / lets you stack them vertically.","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"note: Note\nThe choice of * and / as operators for stacking operations was somewhat arbitrary. * was chosen because it's already what Julia uses to concatenate strings, and you can think of that as \"horizontally stacking them\". / was chosen because it reminds me of fractions, and fractions have one number over another. If you don't like to use these operators, you're in luck! They are really just a  shorthand notation for the functions hstack & vstack. You'll find that this notation makes for some pretty nifty code though.","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"Let's stack things:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"\nimport Term: Panel # hide\n\nprintln(\n    Panel(\"horizontally\"; fit=true) * Panel(\"stacked\"; fit=true)\n)\nprintln(\"&\\n\")\nprintln(\n    Panel(\"vertically\"; fit=true) / Panel(\"stacked\"; fit=true)\n)\n","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"As simple as that. But you can also go crazy if you like:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"\nimport Term: Panel # hide\n\np = Panel(width=5)\nprintln(\n    (p * p * p) / (p * (p/p)) / (p * p * \"[bold red]supripse![/bold red]\")\n)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"what's that red text doing in there? We didn't use tprint, or apply_style, we didn't put it into a RenderableText or a TextBox (see Renderables)... why didn't it print as \"[bold red]supripse![/bold red]\"??","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"The answer is that stacking operators return the generic Renderable type object, and Renderables apply their styles before printing out to console. Okay, not a huge surprise I guess, but I just wanted an excuse to say that regardless of what goes into * and / the output is a generic Renderable (well with the exception of * between two strings which returns a string; also * and / don't work with things like ::Number & co., but you get the idea). The reason for the generic Renderable type is that the product of two stacked renderables should act as a unitary single renderable in its own right. You should be able to print it, stack it etc... So Renderable is the simplest type of renderable that can do this (it only has segments and measure, no other features - see previous section), so when we stack together multiple different types of renderables we create a generic container. ","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"Previously we briefly mentioned the idea of the Measure or a renderable object. Measure stores information about the width and height of a renderable as it will appear in the terminal. When we stack renderables, the Measure of the resulting Renderable will do the following:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"if we are using * the width will be the sum of widths of the two renderables and the height will be the height  of the tallest renderable\nif we are using / the width will be that of the widest renderable and the height will be the sum of heights. ","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"Let's see:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term: Panel # hide\np1 = Panel(width=5, height=5)\nprintln(\"p1.measure: \", p1.measure)\n\n\np2 = Panel(width=8, height=5)\nprintln(\"p2.measure: \", p2.measure)\n\nh = p1 * p2\nprintln(\"* stacked measure: \", h.measure)\n\nv = p1 / p2\nprintln(\"/ stacked measure: \", v.measure)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"This is important, because often you want to know a Renderable's size when creating a layout, as we'll see next.","category":"page"},{"location":"basics/content_layout/#Spacer","page":"Content layout","title":"Spacer","text":"","category":"section"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"Okay, we can stack two Panels side by side. It looks like this:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"using Term # hide\n\np = Panel(width=5, height=3)\nprint(p * p)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"but what if we want some space between them? We can do something like","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"using Term # hide\np = Panel(\" \"; fit=true) # hide\nprint(p * \" \"^5 * p)\nprint(p / \"\\n\"^2 / p)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"to create horizontal and vertical spaces. But what if we want to separate two renderables by a space that is 4 characters wide and 3 lines high? We could create a string which does that and stack it with our renderables... Doesn't sound fun. That's why Term has a Spacer renderable object that does it for your:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term: Panel # hide\nimport Term: Spacer\np = Panel(width=5, height=3) # hide\n\nspace = Spacer(5, 3; char=',')\nprint(p * space * p)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"here we're using the optional argument char to fill the spacer with a character so that we can see what it looks like. Normally it would be just empty space. The nice thing about spacer is that we can easily do things like this:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term: Panel, Spacer # hide\np = Panel(width=5, height=3) # hide\n\ntop = p * Spacer(5, 3; char='t') * p\nmid = Spacer(top.measure.w, 2; char='m') # use top's Measure info !\nbottom = p * Spacer(5, 3; char='b') * p\n\nprint(top / mid / bottom)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"look at that layout! Actually don't, look at it without that clutter:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term: Panel, Spacer # hide\np = Panel(width=5, height=3) # hide\n\ntop = p * Spacer(5, 5) * p\nmid = Spacer(top.measure.w, 2) # use top's Measure info !\nbottom = p * Spacer(5, 5) * p\n\nprint(top / mid / bottom)","category":"page"},{"location":"basics/content_layout/#vLine","page":"Content layout","title":"vLine","text":"","category":"section"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"Space is nice. You can separate distinct pieces of content so that the message you're trying to convey is more easily interpreted by the user. But space is not enough. Sometimes you want to add a line to mark out where one section ends and the other starts. Well, that's where vLine and hLine below come in. They're very simple to use, just say how tall/weide the line should be and, optionally, give some markup style information too:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term: Panel, Spacer # hide\nimport Term: vLine\np = Panel(width=5, height=3) # hide\n\nl = vLine(p.measure.h; style=\"bold red\")\ns = Spacer(2, p.measure.h)\n\nprint(p * l * s * l * p)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"note: Note\nLike with Panel, vLine and hLine accept a box= keyword argument with the ::Symbol of any of the Box objects supported by Term.","category":"page"},{"location":"basics/content_layout/#hLine","page":"Content layout","title":"hLine","text":"","category":"section"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"I think you can guess where we are going with this. hLine is just like vLine but horizontal:","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"import Term: Panel, Spacer # hide\nimport Term: hLine\n\np = Panel(width=5, height=3) # hide\nl = hLine(20, \"whaaat\"; style=\"bold red\", box=:DOUBLE)\n\n\nprint(p / l / p)","category":"page"},{"location":"basics/content_layout/","page":"Content layout","title":"Content layout","text":"surprise! hLine is not just like vLine: it also accepts an optional text argument to create a little title line if you will. But yeah, otherwise it's just the same. ","category":"page"},{"location":"basics/tprint/#tprint","page":"tprint","title":"tprint","text":"","category":"section"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"We've seen tprint before. When passed a string with markup information it will print it with the correct style.","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"using Term # hide\ntprint(\"This text has [bold gold1 underline]style!\")","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"But there's more. Compare Base.print with Term.tprint here:","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"using Term # hide\nprint(\"This is a: \", 1, \"of type\", typeof(1), \"this is a function\", print)\nprint(\"\\n\") # hide\ntprint(\"This is a: \", 1, \"of type\", typeof(1), \"this is a function\", print)","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"you can see two differences. The first is that when passing multiple comma separated arguments tprint inserts a space between them, making the output easier to parse. The second is that it colors certain objects types (Number, DataType and Function in the example). Thus any number will be printed blue, function names will be yellow etc.","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"Note that tprint can only highlight objects based on their type (e.g., 1 above is of type Int64, not a string \"1\".). So this won't work:","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"using Term # hide\ntprint(\"This is a: 1 of type Int64 this is a function print\")","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"But, we are working on a highlight feature that will be able to parse strings and color their elements correctly. Like this:","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"import Term: tprint, highlight\ntprint(highlight(\"This is a: 1 of type ::Int64 this is a function print\"))","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"Tprint can also print renderables, of course.","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"using Term # hide\ntprint(Panel(; width=22, height=2), Panel(; width=22, height=3))","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"As you can see the renderables are printed one above the other. ","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"Finally, you should know that like print has println, so tprint has tprintln to add a new line to the output.","category":"page"},{"location":"basics/tprint/","page":"tprint","title":"tprint","text":"With this we conclude our overview of the basic elements of Term: markup style to create styled text, tprint to print it to console, renderables like Panel and TextBox and the layout syntax to create beautiful terminal output.  There's a lot more you can use Term for, but styled text, panels and layout operators will get you far! Enjoy!","category":"page"},{"location":"basics/renderables/#Renderables","page":"Renderables","title":"Renderables","text":"","category":"section"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"In the previous section we...","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"using Term  # hidden\ntprint(\"[green]...have seen how to add some [gold3 bold underline]style[/gold3 bold underline] to our text\")  # hidden","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"and that's great, but it's not enough. If you want to create really beutiful and structured terminal outputs, a bit of color and bold text is not enough. You want to be able to create panels to separate different pieces of content, lines to mark out different sections, you want to be able to control the aspect (e.g.,, line length) of the content you're printing and, most importantly, you want to do all this without too many headaches. Term.jl has got your back.","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"In this section we will look at Renderable objects (subtypes of AbstractRenderable) such as TextBox and Panel. Each type of renderable also has a dedicated pages under the section \"Renderables\" where the renderable is described more in detail. Here we will describe renderables in general, while in the coming section we'll talk about building layouts composed of multiple renderables. ","category":"page"},{"location":"basics/renderables/#AbsractRenderable","page":"Renderables","title":"AbsractRenderable","text":"","category":"section"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"This section focuses a bit on how renderables work under the hood. If you just want use Term and you don't care too much for how it works, skip ahead to the next section!","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"When you venture beyond styling simple strings, virtually every object you'll encounter will be a subtype of the  AbstractRenderable type. We will call these objects renderables. Renderable types vary, but they all must have two fields: Segment and Measure:","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"A Segment is roughly equivalent to one line of text. Let's take something like this (printed out in your terminal):","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"╭────────────────────╮\n│                    │\n╰────────────────────╯","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"you can think of this as being made of three segments:","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"# 1\n╭────────────────────╮\n\n# 2\n│                    │\n\n# 3\n╰────────────────────╯","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"When the renderable get's printed each of its segments is printed separately on a new line, giving the illusion of a single object (if we designed the segments correctly).  In addition, the text stored by a Segment already has applied style information to it (i.e. markup tags are converted to ANSI codes), so it's ready to print!","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"In addition to a vector of segments, a renderable is defined by a Measure object. Roughly speaking, a Measure object stores information about the size of a renderable as it will appear in the terminal. Anything can have a measure: a string of text, a segment (the measure of its text) and a renderable (the combined measure of its segments). This information is crucial when we start putting multiple renderables together. For instance the renderable shown above is a Panel and a Panel can be created to fit a piece of text:","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"import Term: Panel\n\nprint(Panel(\"this is [red]RED[/red]\"; fit=true))","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"in order to do that Panel needs to know the size of the text it needs to fit, and that's done by taking its measure (note that the measure correctly ignores the style information to get the size of the text as it will be when printed out). Finally, we can think of the panel itself as having a Measure=(17, 3): 17 is the width of the panel and 3 its height (the number of segments). Again, this information is crucial when creating layouts of multiple renderables:","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"\nimport Term: Panel\n\nprint(Panel(;height=3, width=6) * Panel(; height=5, width=12))","category":"page"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"but more on that in the next section. ","category":"page"},{"location":"basics/renderables/#Other-renderables","page":"Renderables","title":"Other renderables","text":"","category":"section"},{"location":"basics/renderables/","page":"Renderables","title":"Renderables","text":"Term comes with a few different types of renderables (we saw Panel already, but there's more), but the basic idea is that they are made of segments of text and have a measure. Each renderable has its own additional features on top of that, but those are described more in detail in dedicated pages (look left!). Briefly, we have Panel which creates stuff like what we've just seen, RenderableText which handles rendering text in the console (surprise!) and TextBox which is somewhat inbetween the two. Other renderables include things like Tree and, in the future, Table. Now lets look at how we can put multiple renderables together!","category":"page"},{"location":"api/api_introspection/#Introspection","page":"Introspection","title":"Introspection","text":"","category":"section"},{"location":"api/api_introspection/","page":"Introspection","title":"Introspection","text":"CurrentModule = Term.introspection","category":"page"},{"location":"api/api_introspection/","page":"Introspection","title":"Introspection","text":"Pages   = [\"api_introspection.md\"]","category":"page"},{"location":"api/api_introspection/","page":"Introspection","title":"Introspection","text":"Modules = [introspection]","category":"page"},{"location":"api/api_introspection/#Term.introspection.TypeInfo","page":"Introspection","title":"Term.introspection.TypeInfo","text":"TypeInfo\n\nStores metadata about a DataType\n\n\n\n\n\n","category":"type"},{"location":"api/api_introspection/#Term.introspection.TypeInfo-Tuple{DataType}","page":"Introspection","title":"Term.introspection.TypeInfo","text":"TypeInfo(type::DataType)\n\nExtract information from a DataType and store it as a TypeInfo object.\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.TypeInfo-Tuple{Function}","page":"Introspection","title":"Term.introspection.TypeInfo","text":"TypeInfo(fun::Function)\n\nExctract information from a function object\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.get_docstring-Tuple{Any}","page":"Introspection","title":"Term.introspection.get_docstring","text":"get_docstring(obj)\n\nExtract and style an object's docstring.\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.inspect-Tuple{Any}","page":"Introspection","title":"Term.introspection.inspect","text":"generic inspect method, dispatches to type-specific methods when they can be found\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.inspect-Tuple{DataType}","page":"Introspection","title":"Term.introspection.inspect","text":"inspect(type::DataType; width::Int=120)\n\nIntrospect a  type.\n\nExtract  info like docstring, fields, types etc. and show it in a structured terminal output.\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.inspect-Tuple{Function}","page":"Introspection","title":"Term.introspection.inspect","text":"inspect(fun::Function; width::Int=88, max_n_methods::Int = 7)\n\nInspects Function objects providing docstrings, and methods signatures.\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.style_method_line-Tuple{AbstractString}","page":"Introspection","title":"Term.introspection.style_method_line","text":"style_method_line(method::AbstractString; trim::Bool=false)::String\n\nStyle a string with method info (name, args, path...)\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.style_sub_types-Tuple{Any}","page":"Introspection","title":"Term.introspection.style_sub_types","text":"style_sub_types(info)::String\n\nStyle a vector of sub types.\n\n\n\n\n\n","category":"method"},{"location":"api/api_introspection/#Term.introspection.style_super_types-Tuple{Any}","page":"Introspection","title":"Term.introspection.style_super_types","text":"style_super_types(info)::String\n\nStyle a vector of super types \n\n\n\n\n\n","category":"method"},{"location":"api/api_logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"api/api_logging/","page":"Logging","title":"Logging","text":"CurrentModule = Term.logging","category":"page"},{"location":"api/api_logging/","page":"Logging","title":"Logging","text":"Pages   = [\"api_logging.md\"]","category":"page"},{"location":"api/api_logging/","page":"Logging","title":"Logging","text":"Modules = [logging]","category":"page"},{"location":"api/api_logging/#Term.logging.TermLogger","page":"Logging","title":"Term.logging.TermLogger","text":"TermLogger\n\nCustom logger type.\n\n\n\n\n\n","category":"type"},{"location":"api/api_logging/#Logging.handle_message-Tuple{Term.logging.TermLogger, Any, Any, Any, Any, Any, Any, Any}","page":"Logging","title":"Logging.handle_message","text":"Logging.handle_message(logger::TermLogger,\n\nHandle printing of log messages, with style!.\n\nIn addition to the log message and info such as file/line and time of log,  it prints kwargs styled by their type.\n\n\n\n\n\n","category":"method"},{"location":"api/api_logging/#Term.logging.install_term_logger","page":"Logging","title":"Term.logging.install_term_logger","text":"install_term_logger(theme::Theme=theme)\n\nInstall TermLogger as the global logging system.\n\ntheme::Theme can be passed to specify the theme to use for styling objects.\n\n\n\n\n\n","category":"function"},{"location":"api/api_logging/#Term.logging.print_closing_line","page":"Logging","title":"Term.logging.print_closing_line","text":"print_closing_line(color::String, width::Int)\n\nPrint the final line of a log message with style and date info\n\n\n\n\n\n","category":"function"},{"location":"api/api_markup/#Markup","page":"Markup","title":"Markup","text":"","category":"section"},{"location":"api/api_markup/","page":"Markup","title":"Markup","text":"CurrentModule = Term.markup","category":"page"},{"location":"api/api_markup/","page":"Markup","title":"Markup","text":"Pages   = [\"api_markup.md\"]","category":"page"},{"location":"api/api_markup/","page":"Markup","title":"Markup","text":"Modules = [markup]","category":"page"},{"location":"api/api_segment/#Segment","page":"Segment","title":"Segment","text":"","category":"section"},{"location":"api/api_segment/","page":"Segment","title":"Segment","text":"CurrentModule = Term.segment","category":"page"},{"location":"api/api_segment/","page":"Segment","title":"Segment","text":"Pages   = [\"api_segment.md\"]","category":"page"},{"location":"api/api_segment/","page":"Segment","title":"Segment","text":"Modules = [segment]","category":"page"},{"location":"api/api_segment/#Term.segment.Segment","page":"Segment","title":"Term.segment.Segment","text":"Segment\n\nstores one piece of text with all the styles applied to it.\n\n\n\n\n\n","category":"type"},{"location":"api/api_segment/#Term.segment.Segment-Tuple{String, String}","page":"Segment","title":"Term.segment.Segment","text":"Segment(text::Union{Segment, AbstractString}, markup::AbstractString)\n\nConstruct a Segment out of a plain string and a markup string with style info\n\n\n\n\n\n","category":"method"},{"location":"api/api_segment/#Term.segment.Segment-Tuple{String}","page":"Segment","title":"Term.segment.Segment","text":"Segment(text::AbstractString)\n\nConstruct a Segment out of a string with markup.\n\n\n\n\n\n","category":"method"},{"location":"api/api_segment/#Base.:*-Tuple{Term.segment.Segment, AbstractString}","page":"Segment","title":"Base.:*","text":"concatenate strings and segments\n\n\n\n\n\n","category":"method"},{"location":"api/api_segment/#Base.show-Tuple{IO, Term.segment.Segment}","page":"Segment","title":"Base.show","text":"print styled in stdout, info otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/api_segment/#Term.fillin-Tuple{Vector{Term.segment.Segment}}","page":"Segment","title":"Term.fillin","text":"Term.fillin(segments::Vector{Segment})::Vector{Segment}\n\nEnsure that for each segment the text has the same width\n\n\n\n\n\n","category":"method"},{"location":"ren/tree/#TreeDoc","page":"Tree","title":"Tree","text":"","category":"section"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"The Tree renderable shows hierarchical structures:","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"import Term.tree: Tree\n\ndata = Dict(\n    \"a\" => 1,\n    \"b\" => Int64,\n    \"c\" => (1, 2, 3),\n)\n\nprint(Tree(data))","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"As you can see, the starting point is a Dict with key -> value entries which get rendered as leaves in the tree. Also, the Type of value is shown by colors in the tree.","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"If you have nested data, just create nested dictionaries!","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"\ndata = Dict(\n    \"a\" => 1,\n    \"b\" => Int64,\n    \"deep\" => Dict(\n            \"x\" => 1,\n            \"y\" => :x\n    ),\n)\n\nprint(Tree(data))","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"Easy! `Tree has lots of options to allow you to style it as you like:","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"print(\n    Tree(data,\n        title=\"my custom tree\",\n        title_style=\"red\",\n        guides_style=\"green\",\n        guides_type=:boldtree\n    \n    )\n)","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"And of course trees behave just like any renderable so you can create layouts with them:","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"import Term: Panel, Tree\ndata = Dict(\n    \"a\" => 1,\n    \"b\" => Int64,\n    \"deep\" => Dict(\n            \"x\" => 1,\n            \"y\" => :x\n    ),\n)\n\ntree = Tree(data)\n\nprint(\n    (\"\\n\" / tree) * \"  \" * Panel(tree; fit=true)\n)","category":"page"},{"location":"ren/tree/#TypeTree","page":"Tree","title":"TypeTree","text":"","category":"section"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"As you know, Julia allows for hierarchical types structures. Trees are for visualizing hierarchical data structures. So...","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"import Term: typestree\n\ntypestree(AbstractFloat)","category":"page"},{"location":"ren/tree/","page":"Tree","title":"Tree","text":"Enjoy!","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Term","category":"page"},{"location":"#Term","page":"Home","title":"Term","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Term.jl is a Julia library for producing styled, beautiful terminal output, like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Term\nprint(Term.make_logo())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Term.jl uses a simple markup syntax to add style information to standard Julia strings. It also provides Renderable objects such as the Panel and TextBox as you can see in the example below. These too can be styled, include styled text, and they can be nested and stacked to produce structured visual displays in your terminal. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Code under development\nWhile we're happy enough with Term to have people start using it, Term is a very young package under active development. This means that:     - there are likely several bugs that need to be discovered and fixed     - as we expand and improve Term there's likely going to be frequent breaking changes If you're curious about Term and you'd like to start playing around with it, you're more than welcome to join the fun. Infact, you can join on us on GitHub and help us make Term even better! If, however, you're thinking of using Term in production-level code that others will need to rely upon, we ask you to be  patient for a bit longer as we continue to work on Term.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: OS concerns\nTerm has been tested extensively so far, but only on Mac. If you're using a Linux or Windows machine you might find some bugs that have eluded us so far. Please get in touch so that we can fix them!","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: `Term` and `rich`\nWhile Term was written from scratch in Julia, it's based upon a pre-existing python library called rich. If you have never used rich, just know that it's absolutely awesome. And its creator, Will McGugan, made it open source for anyone to use. That also meant people like us could took inspiration from rich to create related packages in other languages. We are very grateful to Will, and we hope that Term will end up being a fraction as cool as rich.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In a Julia script:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"Term\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or in the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]  # enters the pkg interface\npkg> add Term","category":"page"},{"location":"","page":"Home","title":"Home","text":"done!","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rest of the documentation is dedicated to explaining the basic concepts behind Term.jl and how to use Term to produce styled terminal text.  Head to the GitHub repository to find several detailed examples or jump in the Discussions to start chatting with us. ","category":"page"},{"location":"#Getting-in-touch","page":"Home","title":"Getting in touch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to get in touch with us, the easiest way is on GitHub. You can open an issue to report a bug or ask for a new feature or join the discussions for more general chats about Term. The discussion section is also a good place to go for general questions about Term and how to use it. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Term is written to be a useful piece of software for anyone using Julia, from beginners to more advanced users. If you're comfortable writing and testing code, you can jump in right now and start actively working on Term with us. If you're not, that's totally fine. There's a lot of ways in which you can help: open an issue to report problems with Term, ask questions on GitHub, help expand the docs and examples for other users too. Or just tell us what you're experience using Term was like, any feedback can help us improve!.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As mentioned, Term is inspired on rich in python. There's also a project called Spectre console which is a .NET Standard 2.0 version of rich.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia there's several pre-existing packages aimed at producing styling terminal output, we note in particular:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Crayons\nAnsiColor","category":"page"},{"location":"api/api_tprint/#Layout","page":"Layout","title":"Layout","text":"","category":"section"},{"location":"api/api_tprint/","page":"Layout","title":"Layout","text":"CurrentModule = Term.Tprint","category":"page"},{"location":"api/api_tprint/","page":"Layout","title":"Layout","text":"Pages   = [\"api_tprint.md\"]","category":"page"},{"location":"api/api_tprint/","page":"Layout","title":"Layout","text":"Modules = [Tprint]","category":"page"},{"location":"api/api_tprint/#Term.Tprint.tprint","page":"Layout","title":"Term.Tprint.tprint","text":"tprint\n\nSimilar to standard lib's print function but with added styling functionality\n\n\n\n\n\n","category":"function"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{Any}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x)\n\nWhen no dedicated method is present, print the string representation\n\n\n\n\n\n","category":"method"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{DataType}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x::DataType)\n\nPrint highlighted as a DataType\n\n\n\n\n\n","category":"method"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{Function}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x::Function)\n\nPrint highlighted as a Function\n\n\n\n\n\n","category":"method"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{IO, AbstractString}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x::AbstractString)\n\nApply style to a string and print it to a new line\n\n\n\n\n\n","category":"method"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{Number}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x::Number)\n\nPrint highlighted as a Number\n\n\n\n\n\n","category":"method"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{Symbol}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x::Symbol)\n\nPrint highlighted as a Symbol\n\n\n\n\n\n","category":"method"},{"location":"api/api_tprint/#Term.Tprint.tprint-Tuple{Term.renderables.AbstractRenderable}","page":"Layout","title":"Term.Tprint.tprint","text":"tprint(x::AbstractRenderable)\n\nPrint an AbstractRenderable.\n\nEquivalent to println(x)\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term","page":"Term","title":"Term","text":"","category":"section"},{"location":"api/api_term/","page":"Term","title":"Term","text":"CurrentModule = Term","category":"page"},{"location":"api/api_term/","page":"Term","title":"Term","text":"Pages   = [\"api_term.md\"]","category":"page"},{"location":"api/api_term/","page":"Term","title":"Term","text":"Modules = [Term]","category":"page"},{"location":"api/api_term/#Term.OPEN_TAG_REGEX","page":"Term","title":"Term.OPEN_TAG_REGEX","text":"This regex uses lookahead and lookbehind to exclude [[ at the beginning of a tag, with this:     (?<![)[(?![)\n\n\n\n\n\n","category":"constant"},{"location":"api/api_term/#Term.AnsiTag","page":"Term","title":"Term.AnsiTag","text":"Store information about the location and style of an ansi tag\n\n\n\n\n\n","category":"type"},{"location":"api/api_term/#Term.CodeTheme","page":"Term","title":"Term.CodeTheme","text":"Custom hilighting theme for Highlighters.jl https://juliadocs.github.io/Highlights.jl/stable/man/theme/\n\n\n\n\n\n","category":"type"},{"location":"api/api_term/#Term.Theme","page":"Term","title":"Term.Theme","text":"Theme\n\nStores colors for different semantically relevant items, used to  style outputs to terminal.\n\n\n\n\n\n","category":"type"},{"location":"api/api_term/#Term.measure.Measure-Tuple{Term.segment.Segment}","page":"Term","title":"Term.measure.Measure","text":"Measure(seg::Segment)\n\ngives the measure of a segment\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.measure.Measure-Tuple{Vector{Term.segment.Segment}}","page":"Term","title":"Term.measure.Measure","text":"Measure(segments::Vector{Segment})\n\ngives the measure of a vector of segments\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Highlights.Format.render-Tuple{IO, MIME{Symbol(\"text/ansi\")}, Highlights.Format.TokenIterator}","page":"Term","title":"Highlights.Format.render","text":"Format.render(io::IO, ::MIME\"text/ansi\", tokens::Format.TokenIterator)\n\ncustom ANSI lexer for Highlighters.jl\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.chars-Tuple{AbstractString}","page":"Term","title":"Term.chars","text":"Split a string into a vector of Chars.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.cleantext-Tuple{Any}","page":"Term","title":"Term.cleantext","text":"cleantext(str::AbstractString)\n\nRemove all style information from a string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.correct_newline_style-Tuple{Any}","page":"Term","title":"Term.correct_newline_style","text":"correct_newline_style(text)\n\nGiven a multi-line text with ANSI style, add an ANSI close tag at the end of each line and restore the style in the next.\n\nThis is important for reshaped text that needs to be put in layouts with other text and you don't want the ANSI style to bleed into other renderables.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.do_by_line-Tuple{Function, Any}","page":"Term","title":"Term.do_by_line","text":"do_by_line(fn::Function, text::String)\n\nApply fn to each line in the text.\n\nThe function fn should accept a single ::String argument.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.escape_brackets-Tuple{Any}","page":"Term","title":"Term.escape_brackets","text":"remove_ansi(str)::String\n\nReplace each squared bracket with a double copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.excise_style-Tuple{Any}","page":"Term","title":"Term.excise_style","text":"excise_style(text)::Tuple{String, Vector{AnsiTag}, Bool}\n\nCut ANSI style information out of a string and store ANSI tags locations.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.fillin-Tuple{Any}","page":"Term","title":"Term.fillin","text":"fillin(text::String)::String\n\nEnsure that each line in a multi-line text has the same width.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.get_ANSI_codes-Tuple{Any}","page":"Term","title":"Term.get_ANSI_codes","text":"get_ANSI_codes(text)::String\n\nReturns a string with all ANSI codes in the input.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.get_last_ANSI_code-Tuple{Any}","page":"Term","title":"Term.get_last_ANSI_code","text":"get_last_ANSI_code(text)::String\n\nGet the last ANSI code in a sting, returns \"\" if no ANSI code found.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.get_lr_widths-Tuple{Int64}","page":"Term","title":"Term.get_lr_widths","text":"getlrwidths(width::Int)\n\nTo split something with width in 2, get the lengths of the left/right widths.\n\nWhen width is even that's easy, when it's odd we need to be careful.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.get_text_info-Tuple{Any}","page":"Term","title":"Term.get_text_info","text":"get_text_info(text)\n\nExtract a bunch of information from a string of text. Info includes with at each char, number of codeunits at each char, which characters are spaces and wether the text is 'simple' (i.e. each char has ncodeunits=1) or not.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.has_ansi-Tuple{Any}","page":"Term","title":"Term.has_ansi","text":"has_markup(text::String)\n\nReturns true if text includes a MarkupTag\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.has_markup-Tuple{String}","page":"Term","title":"Term.has_markup","text":"has_markup(text::String)\n\nReturns true if text includes a MarkupTag\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.highlight-Tuple{AbstractString, Symbol}","page":"Term","title":"Term.highlight","text":"highlight(text::AbstractString, theme::Theme, like::Symbol)\n\nHilights an entire text as if it was a type of semantically relevant text of type :like.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.highlight-Tuple{AbstractString}","page":"Term","title":"Term.highlight","text":"highlight(text::AbstractString, theme::Theme)\n\nHighlighs a text introducing markup to style semantically relevant segments, colors specified by a theme object\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.highlight_syntax-Tuple{AbstractString}","page":"Term","title":"Term.highlight_syntax","text":"highlight_syntax(code::AbstractString; style::Bool=true)\n\nHighlight Julia code syntax in a string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.join_lines-Tuple{Vector{String}}","page":"Term","title":"Term.join_lines","text":"join_lines(lines)\n\nMerge a vector of strings in a single string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.load_code_and_highlight-Tuple{AbstractString, Int64}","page":"Term","title":"Term.load_code_and_highlight","text":"load_code_and_highlight(path::AbstractString, lineno::Int; δ::Int=3, width::INt=120)\n\nLoad a file, get the code and format it. Return styled text\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.loop_last-Tuple{Any}","page":"Term","title":"Term.loop_last","text":"loop_last(v)\n\nReturns an iterable yielding tuples (is_last, value).\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.nospaces-Tuple{AbstractString}","page":"Term","title":"Term.nospaces","text":"nospaces(text::AbstractString)\n\nRemove all spaces from a string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.or-Tuple{Any, Any}","page":"Term","title":"Term.or","text":"or(x, y)\n\nReturn y if x is Nothing\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.read_file_lines-Tuple{AbstractString, Int64, Int64}","page":"Term","title":"Term.read_file_lines","text":"read_file_lines(path::String, start::Int, stop::Int)\n\nRead a file and select only lines in range start -> stop.\n\nReturns a vector of tuples with the line number and line content.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.reinject_style-Tuple{Any, Vector{Term.AnsiTag}, Vector{Int64}, Bool}","page":"Term","title":"Term.reinject_style","text":"reinject_style(text, tags::Vector{AnsiTag}, cuts::Vector{Int})\n\nRe-insert previously excised ANSI style tags. If the cleaned text was reshaped, cuts stores information about where new lines were added so that the ANSI style can be added in the right place.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.remove_ansi-Tuple{Any}","page":"Term","title":"Term.remove_ansi","text":"remove_ansi(input_text::AbstractString)::AbstractString\n\nRemove all ANSI tags from a string of text\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.remove_brackets-Tuple{Any}","page":"Term","title":"Term.remove_brackets","text":"remove_brackets(text::AbstractString)\n\nRemove all () brackets from a string.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.remove_markup-Tuple{Any}","page":"Term","title":"Term.remove_markup","text":"remove_markup(input_text::AbstractString)::AbstractString\n\nRemove all markup tags from a string of text.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.replace_ansi-Tuple{Any}","page":"Term","title":"Term.replace_ansi","text":"replace_ansi(input_text)\n\nReplace ANSI tags with ¦.\n\nThe number of '¦' matches the length of the ANSI tags. Used when we want to hide ANSI tags but keep the string length intact.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.replace_multi-Tuple{Any, Vararg{Any}}","page":"Term","title":"Term.replace_multi","text":"multiple strings replacement, for multiple on Julia version \n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.replace_text","page":"Term","title":"Term.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, char::Char='_')\n\nReplace a section of a text  between start and stop with another string composed of repeats of a given character char.\n\n\n\n\n\n","category":"function"},{"location":"api/api_term/#Term.replace_text-Tuple{Any, Int64, Int64, String}","page":"Term","title":"Term.replace_text","text":"replace_text(text::AbstractString, start::Int, stop::Int, replace::AbstractString)\n\nReplace a section of a text between start and stop with replace.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.reshape_text-Tuple{Any, Int64}","page":"Term","title":"Term.reshape_text","text":"reshape_text(text, width::Int)\n\nReshape a string to have max width when printed out.\n\nCut the string into multiple lines so that each line has at most width when printed to terminal: ignoring ANSI style but taking into account characters with widths > 1. Text is preferentially split at a space when possible to improve readability.\n\nFuture developer, this function is highly optimized to reshape text as accurately as possible and as fast as possible. It took several days to get it to be able to handle  style information correctly, handle multi codeunit characters, handle characters with width >1, handle situations in which the string can't be split up at a space etc... It's a very delicate balance to get everything right and changing anything can cause the whole thing to break, so do so at your peril!\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.split_lines-Tuple{Any}","page":"Term","title":"Term.split_lines","text":"split_lines(renderable)\n\nSplit a renderable's text.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.split_lines-Tuple{String}","page":"Term","title":"Term.split_lines","text":"split_lines(text::AbstractString)\n\nSplit a string into its composing lines.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.textlen-Tuple{String}","page":"Term","title":"Term.textlen","text":"textlen(x::AbstractString)\n\nGet length of text after all style information is removed.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.truncate-Tuple{AbstractString, Int64}","page":"Term","title":"Term.truncate","text":"truncate(text::AbstractString, width::Int)\n\nShorten a string of text to a target width\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.tview-Tuple{Any, Int64, Int64}","page":"Term","title":"Term.tview","text":"tview(text, start::Int, stop::Int)\n\nGet a view object with appropriate indices\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.unescape_brackets-Tuple{Any}","page":"Term","title":"Term.unescape_brackets","text":"unescape_brackets(text)::String\n\nReplece every double squared parenthesis with a single copy of itself\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.unspace_commas-Tuple{Any}","page":"Term","title":"Term.unspace_commas","text":"unspace_commas(text::AbstractString)\n\nRemove spaces after commas.\n\n\n\n\n\n","category":"method"},{"location":"api/api_term/#Term.@make_color_macro-Tuple{Any}","page":"Term","title":"Term.@make_color_macro","text":"Macro to create macros such as @green which colors text accordingly\n\n\n\n\n\n","category":"macro"},{"location":"api/api_term/#Term.@make_mode_macro-Tuple{Any}","page":"Term","title":"Term.@make_mode_macro","text":"Macro to create macros such as @underline which styles text accordingly.\n\n\n\n\n\n","category":"macro"},{"location":"api/api_term/#Term.@style-Tuple{Any, Vararg{Any}}","page":"Term","title":"Term.@style","text":"@style \"text\" style1 style2...\n\nApplies a sequence of styles to a piece of text, such that\n\nprintln(@style \"my text\" bold green underline)\n\nwill print my text as bold, green and underlined\n\n\n\n\n\n","category":"macro"}]
}
